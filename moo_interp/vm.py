import inspect
import traceback
import warnings
from enum import Enum
from functools import wraps
from logging import basicConfig, getLogger
from typing import Any, Callable, Dict, List, Mapping, Optional, Tuple, Union

from attr import define, field
from lambdamoo_db.database import MooDatabase

from .builtin_functions import BuiltinFunctions
from .list import MOOList
from .map import MOOMap
from .moo_types import (Addable, Comparable, Container, MapKey, MOOAny,
                        MOONumber, Subtractable, is_truthy)
from .opcodes import Extended_Opcode, Opcode
from .string import MOOString

# basicConfig(level="DEBUG")
logger = getLogger(__name__)

""" LambdaMOO Virtual Machine

    This module implements the LambdaMOO Virtual Machine, which is
    responsible for executing the bytecode generated by the compiler.
    The VM is a stack machine with a single stack of values and a
    separate call stack.  The VM is also responsible for handling
    errors, which are represented by Python exceptions.
"""


class VMError(Exception):
    """Base class for all VM errors"""
    pass


class FinallyReason(Enum):
    FIN_FALL_THRU = 0
    FIN_RAISE = 1
    FIN_UNCAUGHT = 2
    FIN_RETURN = 3
    FIN_ABORT = 4
    FIN_EXIT = 5


class VMOutcome(Enum):
    OUTCOME_DONE = 0  # Task ran successfully to completion
    OUTCOME_ABORTED = 1  # Task aborted, either by kill_task or by an uncaught error
    OUTCOME_BLOCKED = 2  # Task called a blocking built-in function


@define
class Instruction:
    """Represents a single bytecode instruction"""
    opcode: Union[Opcode, int]
    operand: Optional[MOOAny | Extended_Opcode] = None
    label: Optional[int] = None
    loop_var: Optional[MOOString] = None # i
    loop_index: Optional[MOOString] = None # j
    jump_target: Optional[int] = None

@define
class Program:
    first_lineno: int = field(default=1)
    literals: List[Any] = field(factory=list)
    fork_vectors: List[int] = field(factory=list)
    var_names: List[MOOString] = field(factory=list)


@define
class StackFrame:
    """Represents a single frame in the call stack"""
    func_id: int
    prog: Program
    ip: int
    stack: List[Any] = field(factory=list)
    rt_env: List[Any] = field(factory=list)
    bf_ip: int = field(default=0)
    temp: Optional[int] = field(default=0)
    this: int = field(default=0)
    player: int = field(default=0)
    verb: str = field(default="")
    verb_name: str = field(default="")
    debug: bool = field(default=False)
    threaded: bool = field(default=False)
    loop_stack: List[Any] = field(factory=list)  # Stack for loop state tracking

    @property
    def current_instruction(self) -> Instruction:
        """The current instruction"""       
        return self.stack[self.ip]

def operator(opcode):
    """Operator decorator.
    """
    def decorator(func):
        sig = inspect.signature(func)
        func_params = list(sig.parameters.values())[1:]  # Skip 'self'

        num_args = len(func_params)

        unannotated_params = [
            param.name for param in func_params if param.annotation is inspect._empty]

        if unannotated_params:
            warnings.warn(
                f"Parameter(s) {', '.join(unannotated_params)} of {func.__name__} are not annotated, will be considered as 'Any'")

        def typecheck(args, func_params):
            for arg, param in zip(args, func_params):
                if param.annotation not in {inspect._empty, Any}:
                    continue
                if not isinstance(arg, param.annotation):
                    raise VMError(
                        f"Expected {param.annotation} for parameter {param.name}, got {type(arg)}")

        @wraps(func)
        def wrapper(self, *args):
            # Check for stack underflow
            # Skip check for opcodes that get args from instruction operand, not stack
            operand_from_instruction = {Opcode.OP_PUSH, Opcode.OP_IMM, Opcode.OP_PUT, Opcode.OP_POP,
                                        Opcode.OP_JUMP, Opcode.OP_WHILE, Opcode.OP_IF, Opcode.OP_EIF, Opcode.OP_IF_QUES}
            if isinstance(opcode, Opcode) and opcode not in operand_from_instruction:
                if len(self.stack) < num_args:
                    raise VMError(
                        f"Stack underflow in opcode {opcode} in function {func.__name__}")

                typecheck(self.stack[-num_args:], func_params)
            # Call the function
            return func(self, *args)

        # Store the opcode and number of arguments on the function itself
        if isinstance(opcode, Opcode):
            wrapper.opcode = opcode
        elif isinstance(opcode, Extended_Opcode):
            wrapper.eopcode = opcode
        wrapper.num_args = num_args

        return wrapper
    return decorator


@define
class VM:
    """The virtual machine"""

    stack: List[Any] = field(factory=list)
    call_stack: List[StackFrame] = field(factory=list)
    result: MOOAny = field(default=0)
    state: Union[VMOutcome, None] = field(default=None)
    opcode_handlers: Dict[Union[Opcode, Extended_Opcode],
                          Callable] = field(factory=dict, repr=False)
    db: Optional[MooDatabase] = field(default=None)
    bi_funcs: Dict[int, Callable] = field(factory=dict, repr=False)

    def __init__(self, db=None, bi_funcs=None):
        super().__init__()
        self.stack = []
        self.call_stack = []
        self.result = 0
        self.state = None
        self.opcode_handlers = {}
        self.bi_funcs = bi_funcs if bi_funcs else BuiltinFunctions()
        self.db = db
        handled_opcodes = set()

        # Register all opcode handlers
        for name in dir(self):
            if not name.startswith('exec'):
                continue
            method = getattr(self, name, None)
            if hasattr(method, 'opcode') or hasattr(method, 'eopcode'):
                opcode = method.opcode if hasattr(
                    method, 'opcode') else method.eopcode
                self.opcode_handlers[opcode] = method
                handled_opcodes.add(opcode)

        # Set of all opcodes
        all_opcodes = set(Opcode)
        unhandled_opcodes = all_opcodes - handled_opcodes

        if unhandled_opcodes:
            warnings.warn(
                f"The following {len(unhandled_opcodes)} opcodes are not implemented: {[opcode.name for opcode in unhandled_opcodes]}", UserWarning)

        # Set of all extended opcodes
        all_eopcodes = set(Extended_Opcode)
        unhandled_eopcodes = all_eopcodes - handled_opcodes

        if unhandled_eopcodes:
            warnings.warn(
                f"The following {len(unhandled_eopcodes)} extended opcodes are not implemented: {[opcode.name for opcode in unhandled_eopcodes]}", UserWarning)

    def push(self, value: MOOAny) -> None:
        """Push a value onto the stack"""
        self.stack.append(value)

    def pop(self) -> MOOAny:
        """Pop a value off the stack"""
        try:
            return self.stack.pop()
        except IndexError:
            raise VMError("Stack underflow")

    def peek(self) -> Any:
        """Peek at the top value on the stack"""
        try:
            return self.stack[-1]
        except IndexError:
            raise VMError("Stack underflow")

    def run(self):
        """Run the program"""
        while self.state is None:
            self.step()
            yield self.stack

    @property
    def current_frame(self) -> StackFrame:
        """The current stack frame"""
        try:
            return self.call_stack[-1]
        except IndexError:
            raise VMError("No current stack frame")

    def step(self) -> None:
        """Execute the next instruction in the current stack frame."""
        if not self.call_stack:
            return

        frame = self.current_frame

        if frame.ip >= len(frame.stack):
            # Frame has no more instructions - pop it and finish or continue
            self.call_stack.pop()
            if self.call_stack:
                # There are more frames - continue execution
                return
            else:
                # This was the last frame - get result from VM stack if available
                self.result = self.stack[-1] if self.stack else 0
                self.state = VMOutcome.OUTCOME_DONE
                return
        result = None
        instr = frame.current_instruction
        handler = self.opcode_handlers.get(instr.opcode)
        if not handler:
            # Handle extended opcode
            if instr.opcode == Opcode.OP_EXTENDED:
                handler = self.opcode_handlers.get(
                    Extended_Opcode(instr.operand))
                if not handler:
                    raise VMError(f"Unknown extended opcode {instr.operand}")
            if not handler:
                if type(instr.opcode) == int:
                    result = int(instr.opcode) - 113
                else:
                    raise VMError(f"Unknown opcode {instr.opcode}")
        if result is None:
            logger.debug(f"Executing {instr.opcode} {instr.operand}")
            args = []
            if instr.opcode in {Opcode.OP_PUSH, Opcode.OP_PUT, Opcode.OP_IMM, Opcode.OP_POP, Opcode.OP_JUMP, Opcode.OP_WHILE, Opcode.OP_IF, Opcode.OP_EIF, Opcode.OP_IF_QUES}:
                args = [instr.operand]
            elif handler is not None and handler.num_args:
                args = self.stack[-handler.num_args:]

            logger.debug(f"Args: {args}")

            try:
                if instr.opcode != Opcode.OP_POP and handler is not None:
                    result = handler(*args)

                    if handler.num_args and instr.opcode not in {Opcode.OP_PUSH,  Opcode.OP_IMM, }:
                        del self.stack[-handler.num_args:]
            except Exception as e:
                raise VMError(f"Error executing opcode: {e}")

        # Push result if we have one (either from handler or from int opcode)
        if result is not None:
            self.push(result)
        frame.ip += 1

    # Basic opcode implementations
    @operator(Opcode.OP_JUMP)
    def exec_jump(self, offset: int):
        """Jumps to a different instruction in the bytecode.

        Args:
            offset (int): The label or offset to jump to.
        """
        # -1 to account for step()'s automatic ip += 1 at end
        self.current_frame.ip += offset - 1

    def read_bytes(self, num_bytes: int) -> int:
        """Reads the given number of bytes from the bytecode.

        Args:
            num_bytes (int): The number of bytes to read.

        Returns:
            int: The value represented by the read bytes.
        """
        frame = self.call_stack[-1]  # get current stack frame
        # slice the bytecode from ip to ip + num_bytes and interpret it as an integer
        value = int.from_bytes(
            frame.stack[frame.ip:frame.ip + num_bytes], 'big')
        frame.ip += num_bytes  # increment ip by num_bytes
        return value

    @operator(Opcode.OP_PUSH)
    def exec_push(self, var_name: MOOString):
        """Pushes a value onto the stack.

        Args:
            var_name (str): The name of the variable to push.
        """
        frame = self.current_frame
        # get the index of the variable in the variable names list
        var_index = frame.prog.var_names.index(var_name)
        # push the value at the same index in the runtime environment
        result = frame.rt_env[var_index]
        logger.debug(f"Pushing {result} onto the stack from {var_name}")
        return result

    @operator(Opcode.OP_PUSH_CLEAR)
    def exec_push_clear(self, var_name: MOOString):
        """ called the last time the variable is referenced in the program.

          Args:
            var_name (str): The name of the variable to push.
        """
        frame = self.current_frame
        # get the index of the variable in the variable names list
        var_index = frame.prog.var_names.index(var_name)
        # push the value at the same index in the runtime environment
        self.push(frame.rt_env[var_index])
        # clear the variable from the variable names list and the runtime environment
        frame.prog.var_names.pop(var_index)
        frame.rt_env.pop(var_index)

    @operator(Opcode.OP_PUSH_TEMP)
    def exec_push_temp(self):
        """Pushes the temporary value onto the stack."""
        val = self.current_frame.temp
        self.current_frame.temp = None
        logger.debug(f"Pushing {val} onto the stack from temp")
        return val

    @operator(Opcode.OP_IMM)
    def exec_imm(self, value: MOOAny):
        """Pushes an immediate value onto the stack.

        Args:
            value (Any): The value to push.
        """
        if isinstance(value, str):
            value = MOOString(value)
        return value

    @operator(Opcode.OP_POP)
    def exec_pop(self, num: int = 1):
        for _ in range(num):
            self.pop()

    @operator(Opcode.OP_PUT)
    def exec_put(self, identifier: MOOString):
        return self.put(identifier, self.peek())

    @operator(Opcode.OP_PUT_TEMP)
    def exec_put_temp(self) -> None:
        self.current_frame.temp = self.peek()

    def put(self, identifier: MOOString, value: MOOAny) -> MOOAny:
        """Puts a value into the current stack frame's scope.

        Args:
            identifier (str): The identifier to store the value under.
            value (MOOAny): The value to store.
        """
        frame = self.current_frame
        try:
            index = frame.prog.var_names.index(identifier)
        except ValueError:
            frame.prog.var_names.append(identifier)
            frame.rt_env.append(value)
            logger.debug(f"Put {value} into {identifier}")
            return value
        frame.rt_env[index] = value
        frame.rt_env.append(value)
        logger.debug(f"Put {value} into {identifier}")
        return value

    @operator(Opcode.OP_ADD)
    def exec_add(self, op1: Addable, op2: Addable):
        return op1 + op2

    @operator(Opcode.OP_MINUS)
    def exec_subtract(self, op1: Subtractable, op2: Subtractable) -> Subtractable:
        return op1 - op2

    @operator(Opcode.OP_MULT)
    def exec_multiply(self, op1: MOONumber, op2: MOONumber) -> MOONumber:
        return op1 * op2

    @operator(Opcode.OP_DIV)
    def exec_divide(self, op1: MOONumber, op2: MOONumber) -> MOONumber:
        try:
            return op1 / op2
        except ZeroDivisionError:
            raise VMError("Division by zero")

    @operator(Opcode.OP_MOD)
    def exec_mod(self, op1: MOONumber, op2: MOONumber) -> MOONumber:
        try:
            return op1 % op2
        except ZeroDivisionError:
            raise VMError("Division by zero")

    @operator(Opcode.OP_EQ)
    def exec_eq(self, op1: MOOAny, op2: MOOAny) -> bool:
        return op1 == op2

    @operator(Opcode.OP_IN)
    def exec_in(self, rhs: MOOAny, lhs: Container) -> int:
        # either 0 if not in the list or the index if it is
        index = rhs.find(lhs)
        if index == -1:
            return 0
        return index

    @operator(Opcode.OP_NE)
    def exec_ne(self, op1: MOOAny, op2: MOOAny) -> bool:
        return op1 != op2

    @operator(Opcode.OP_LT)
    def exec_lt(self, op1: Comparable, op2: Comparable) -> bool:
        return op1 < op2

    @operator(Opcode.OP_LE)
    def exec_le(self, op1: Comparable, op2: Comparable) -> bool:
        return op1 <= op2

    @operator(Opcode.OP_GT)
    def exec_gt(self, op1: Comparable, op2: Comparable) -> bool:
        return op1 > op2

    @operator(Opcode.OP_GE)
    def exec_ge(self, op1: Comparable, op2: Comparable) -> bool:
        return op1 >= op2

    @operator(Opcode.OP_AND)
    def exec_and(self, op1: MOOAny, op2: MOOAny) -> bool:
        return op1 and op2

    @operator(Opcode.OP_OR)
    def exec_or(self, op1: MOOAny, op2: MOOAny) -> bool:
        return op1 or op2

    @operator(Opcode.OP_NOT)
    def exec_not(self, operand: MOOAny) -> bool:
        return not operand

    @operator(Opcode.OP_UNARY_MINUS)
    def exec_unary_minus(self, op1: MOONumber):
        return -op1

    # Extended opcode implementations

    @operator(Extended_Opcode.EOP_BITOR)
    def exec_bitor(self, op1: int, op2: int):
        return op1 | op2

    @operator(Extended_Opcode.EOP_BITAND)
    def exec_bitand(self, op1: int, op2: int) -> int:
        return op1 & op2

    @operator(Extended_Opcode.EOP_BITXOR)
    def exec_bitxor(self, op1: int, op2: int) -> int:
        return op1 ^ op2

    @operator(Extended_Opcode.EOP_BITSHL)
    def exec_bitshl(self, op1: int, op2: int) -> int:
        return op1 << op2

    @operator(Extended_Opcode.EOP_BITSHR)
    def exec_bitshr(self, op1: int, op2: int) -> int:
        return op1 >> op2

    @operator(Extended_Opcode.EOP_EXP)
    def exec_exp(self, lhs: MOONumber,   rhs: MOONumber):
        return lhs ** rhs

    # List operations

    @operator(Opcode.OP_MAKE_EMPTY_LIST)
    def exec_make_empty_list(self) -> MOOList:
        return MOOList()

    @operator(Opcode.OP_LIST_ADD_TAIL)
    def exec_list_add_tail(self, lst: MOOList, tail: MOOAny) -> MOOList:
        if not isinstance(lst, MOOList):
            raise VMError("Expected list")
        lst.append(tail)
        return lst

    @operator(Opcode.OP_LIST_APPEND)  # extend in Python
    def exec_list_append(self, lst1: MOOList, lst2: MOOList) -> MOOList:
        if not isinstance(lst1, MOOList) or not isinstance(lst2, MOOList):
            raise VMError("Expected list")
        return lst1 + lst2

    @operator(Opcode.OP_MAKE_SINGLETON_LIST)
    def exec_make_singleton_list(self, value: MOOAny) -> MOOList:
        return MOOList(value)

    @operator(Opcode.OP_CHECK_LIST_FOR_SPLICE)
    def exec_check_list_for_splice(self):
        if not isinstance(self.peek(), MOOList):
            raise VMError("Expected list")

    @operator(Opcode.OP_REF)
    def exec_ref(self, lst: Container, index: int) -> MOOAny:
        return lst[index]

    @operator(Opcode.OP_PUSH_REF)
    def exec_push_ref(self, lst: Container, index: int) -> MOOAny:
        raise NotImplementedError()

    @operator(Opcode.OP_RANGE_REF)
    def exec_range_ref(self, lst: Container, start: int, end: int) -> MOOAny:
        if isinstance(lst, MOOString):
            return MOOString(lst[start:end])
        elif isinstance(lst, MOOList):
            return MOOList(lst[start:end])
        else:
            # the keys in our maps are ordered,
            return MOOMap(list(lst.items())[start:end])

    # Map operations

    @operator(Opcode.OP_MAP_CREATE)
    def exec_make_empty_map(self) -> MOOMap:
        return MOOMap()

    @operator(Opcode.OP_MAP_INSERT)
    def exec_map_insert(self, mapping: MOOMap, key: MapKey, value: Any) -> MOOMap:
        if not isinstance(mapping, MOOMap):
            raise VMError("Expected map")
        mapping[key] = value
        return mapping

    # Return Operations

    @operator(Opcode.OP_RETURN)
    def exec_return(self, value: MOOAny) -> MOOAny:
        # Pop the current frame
        self.call_stack.pop()

        # If there are more frames, push return value to the VM stack and continue
        # If this was the last frame, set result and mark as done
        if self.call_stack:
            # Return to caller - push return value onto VM stack for caller to use
            self.push(value)
            return None  # Don't push again
        else:
            # This was the top-level frame - we're done
            self.result = value
            self.state = VMOutcome.OUTCOME_DONE
            return None  # Don't push since we're done

    @operator(Opcode.OP_RETURN0)
    def exec_return0(self) -> int:
        # Pop the current frame
        self.call_stack.pop()

        # If there are more frames, push 0 to the VM stack and continue
        # If this was the last frame, set result and mark as done
        if self.call_stack:
            self.push(0)
            return None
        else:
            self.result = 0
            self.state = VMOutcome.OUTCOME_DONE
            return None

    @operator(Opcode.OP_DONE)
    def exec_done(self):
        self.state = VMOutcome.OUTCOME_DONE
        return 0

    # Verb Call Operations

    @operator(Opcode.OP_CALL_VERB)
    def exec_call_verb(self, obj_id: int, verb_name: MOOString, args: MOOList):
        """Call a verb on an object

        Stack layout (bottom to top, popped in reverse):
        - obj_id: object ID to call verb on (popped last)
        - verb_name: name of verb to call (popped second)
        - args: MOOList of arguments to pass to verb (popped first)
        """
        if not self.db:
            raise VMError("No database available for verb calls")

        # Validate types
        if not isinstance(args, MOOList):
            raise VMError(f"OP_CALL_VERB: args must be MOOList, got {type(args)}")
        if not isinstance(verb_name, MOOString):
            raise VMError(f"OP_CALL_VERB: verb_name must be MOOString, got {type(verb_name)}")
        if not isinstance(obj_id, int):
            raise VMError(f"OP_CALL_VERB: obj_id must be int, got {type(obj_id)}")

        # Find the object
        if obj_id not in self.db.objects:
            raise VMError(f"OP_CALL_VERB: object #{obj_id} not found")

        # Find verb on object or its parents (inheritance chain)
        verb = self._find_verb(obj_id, str(verb_name))
        if not verb:
            raise VMError(f"OP_CALL_VERB: verb '{verb_name}' not found on object #{obj_id}")

        # Check if verb.code is already compiled bytecode (Instructions) or source strings
        # For tests: verb.code may be [Instruction, ...]
        # For real usage: verb.code is ["source line 1", "source line 2", ...]
        if verb.code and isinstance(verb.code[0], Instruction):
            # Already compiled - use directly
            bytecode = verb.code
        else:
            # Source code - compile it
            # Import here to avoid circular dependency
            from .moo_ast import parse, compile as compile_moo

            try:
                code_str = "\n".join(verb.code)
                ast = parse(code_str)
                # Use the VM's bi_funcs instance for consistent builtin IDs
                compiled_frame = compile_moo(ast, bi_funcs=self.bi_funcs)
                bytecode = compiled_frame.stack
            except Exception as e:
                raise VMError(f"OP_CALL_VERB: failed to compile verb '{verb_name}': {e}")

        # Get current frame to copy context from
        caller_frame = self.current_frame if self.call_stack else None

        # Create new stack frame for the verb
        new_frame = StackFrame(
            func_id=verb.object,
            prog=Program(var_names=[MOOString("args"), MOOString("this"), MOOString("caller"), MOOString("player")]),
            ip=0,
            stack=bytecode,
            this=obj_id,
            player=caller_frame.player if caller_frame else 0,
            verb=str(verb_name),
            verb_name=verb.name,
        )

        # Set up runtime environment with special variables
        # In MOO: args, this, caller, player are accessible as variables
        new_frame.rt_env = [
            args,  # args
            obj_id,  # this
            caller_frame.this if caller_frame else 0,  # caller
            caller_frame.player if caller_frame else 0,  # player
        ]

        # Push the new frame onto the call stack
        self.call_stack.append(new_frame)

        # Don't return a value - the verb will execute and eventually OP_RETURN
        return None

    def _find_verb(self, obj_id: int, verb_name: str):
        """Find a verb on an object or its parents (inheritance)

        Args:
            obj_id: Object to search
            verb_name: Name of verb to find

        Returns:
            Verb object if found, None otherwise
        """
        visited = set()  # Prevent infinite loops in inheritance
        to_check = [obj_id]

        while to_check:
            current_id = to_check.pop(0)

            if current_id in visited or current_id not in self.db.objects:
                continue
            visited.add(current_id)

            obj = self.db.objects[current_id]

            # Check verbs on this object
            for verb in obj.verbs:
                if verb.name == verb_name:
                    return verb

            # Add parents to check list
            if hasattr(obj, 'parents') and obj.parents:
                to_check.extend(obj.parents)

        return None

    # Control Flow Operations

    @operator(Opcode.OP_IF)
    def exec_if(self, jump_to: int):
        """Jump if condition is FALSE (skip then-block)."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    @operator(Opcode.OP_EIF)
    def exec_eif(self, jump_to: int):
        """Jump if condition is FALSE (skip elif-block)."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    @operator(Opcode.OP_IF_QUES)  # ternary operator
    def exec_if_ques(self, jump_to: int):
        """Ternary operator - jump if condition is FALSE."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    @operator(Opcode.OP_WHILE)
    def exec_while(self, jump_to: int):
        """While loop - jump past body if condition is FALSE."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    def _skip_to_end_of_for_loop(self, frame):
        """Skip past the loop body to the instruction after OP_JUMP.

        For nested loops, we need to find the JUMP that matches THIS loop,
        not an inner loop's JUMP. We do this by counting nesting depth.
        """
        search_ip = frame.ip + 1
        nesting_depth = 1  # We're inside this loop, looking for its end

        while search_ip < len(frame.stack):
            search_instr = frame.stack[search_ip]

            # Check for nested loop start (increases depth)
            if search_instr.opcode == Opcode.OP_FOR_RANGE:
                nesting_depth += 1
            elif search_instr.opcode == Opcode.OP_EXTENDED:
                # EOP_FOR_LIST_1 and EOP_FOR_LIST_2 are nested loops too
                if search_instr.operand in (Extended_Opcode.EOP_FOR_LIST_1, Extended_Opcode.EOP_FOR_LIST_2):
                    nesting_depth += 1

            # Check for loop end (decreases depth)
            if search_instr.opcode == Opcode.OP_JUMP and isinstance(search_instr.operand, int) and search_instr.operand < 0:
                nesting_depth -= 1
                if nesting_depth == 0:
                    # Found our loop's JUMP
                    frame.ip = search_ip  # Will be incremented by step() to skip past JUMP
                    return

            search_ip += 1

    @operator(Opcode.OP_FOR_RANGE)
    def exec_for_range(self):
        """For-range loop: for i in [start..end]
        Loop state stored on frame.loop_stack as: ('range', ip, current, end)
        """
        frame = self.current_frame
        instr = frame.current_instruction
        loop_var = instr.loop_var

        # Check if we have existing loop state for this IP
        is_first_entry = True
        loop_index = None
        for i, entry in enumerate(frame.loop_stack):
            if len(entry) >= 2 and entry[0] == 'range' and entry[1] == frame.ip:
                is_first_entry = False
                loop_index = i
                break

        if is_first_entry:
            to = self.pop()
            from_val = self.pop()
            if not isinstance(to, int) or not isinstance(from_val, int):
                self._skip_to_end_of_for_loop(frame)
                return None
            if from_val > to:
                self._skip_to_end_of_for_loop(frame)
                return None
            self.put(loop_var, from_val)
            frame.loop_stack.append(('range', frame.ip, from_val + 1, to))
        else:
            _, _, current, to = frame.loop_stack[loop_index]
            if current > to:
                frame.loop_stack.pop(loop_index)
                self._skip_to_end_of_for_loop(frame)
                return None
            self.put(loop_var, current)
            frame.loop_stack[loop_index] = ('range', frame.ip, current + 1, to)
        return None

    @operator(Extended_Opcode.EOP_FOR_LIST_1)
    def exec_for_list_1(self):
        """For-list loop: for x in (list)
        Loop state stored on frame.loop_stack as: ('list', ip, collection, iter_state)
        """
        frame = self.current_frame
        instr = frame.current_instruction
        loop_var = instr.loop_var

        # Check if we have existing loop state for this IP
        is_first_entry = True
        loop_index = None
        for i, entry in enumerate(frame.loop_stack):
            if len(entry) >= 2 and entry[0] == 'list' and entry[1] == frame.ip:
                is_first_entry = False
                loop_index = i
                break

        if is_first_entry:
            base_collection = self.pop()
            if not isinstance(base_collection, MOOList):
                self._skip_to_end_of_for_loop(frame)
                return None
            if len(base_collection) == 0:
                self._skip_to_end_of_for_loop(frame)
                return None
            # MOO lists are 1-indexed, iter_state is next index to use
            self.put(loop_var, base_collection[1])
            frame.loop_stack.append(('list', frame.ip, base_collection, 2))
        else:
            _, _, base_collection, iter_state = frame.loop_stack[loop_index]
            if iter_state > len(base_collection):
                frame.loop_stack.pop(loop_index)
                self._skip_to_end_of_for_loop(frame)
                return None
            self.put(loop_var, base_collection[iter_state])
            frame.loop_stack[loop_index] = ('list', frame.ip, base_collection, iter_state + 1)
        return None

    def _find_loop_end_jump(self, frame):
        """Find the backward JUMP that ends the current loop.

        Returns the IP of the JUMP instruction, or None if not found.
        Uses nesting depth to handle nested loops correctly.
        """
        search_ip = frame.ip + 1
        nesting_depth = 1  # We're inside this loop

        while search_ip < len(frame.stack):
            search_instr = frame.stack[search_ip]

            # Nested loop start increases depth
            if search_instr.opcode == Opcode.OP_FOR_RANGE:
                nesting_depth += 1
            elif search_instr.opcode == Opcode.OP_EXTENDED:
                if search_instr.operand in (Extended_Opcode.EOP_FOR_LIST_1, Extended_Opcode.EOP_FOR_LIST_2):
                    nesting_depth += 1
            elif search_instr.opcode == Opcode.OP_WHILE:
                nesting_depth += 1

            # Backward JUMP decreases depth
            if search_instr.opcode == Opcode.OP_JUMP and isinstance(search_instr.operand, int) and search_instr.operand < 0:
                nesting_depth -= 1
                if nesting_depth == 0:
                    return search_ip

            search_ip += 1
        return None

    @operator(Extended_Opcode.EOP_CONTINUE)
    def exec_continue(self):
        """Continue to next iteration of loop.

        Jump to the loop's ending JUMP instruction, which will then
        jump back to the loop header for the next iteration check.
        """
        frame = self.current_frame
        jump_ip = self._find_loop_end_jump(frame)
        if jump_ip is not None:
            # Set IP to one before the JUMP so step() increments to it
            frame.ip = jump_ip - 1
        return None

    @operator(Extended_Opcode.EOP_EXIT)
    def exec_exit(self):
        """Break out of loop (exit loop).

        Pop loop state and jump past the loop's ending JUMP.
        """
        frame = self.current_frame
        jump_ip = self._find_loop_end_jump(frame)
        if jump_ip is not None:
            # Pop loop_stack for FOR loops
            if frame.loop_stack:
                frame.loop_stack.pop()
            # Set IP to the JUMP; step() will increment past it
            frame.ip = jump_ip
        return None

    @operator(Opcode.OP_BI_FUNC_CALL)
    def exec_bi_func_call(self, args: MOOList) -> MOOAny:
        func_id = self.call_stack[-1].stack[self.call_stack[-1].ip].operand
        func = self.bi_funcs.get_function_by_id(func_id)
        if func is None:
            raise VMError("Unknown built-in function")
        try:
            result = func(*args._list)
        except Exception as e:
            func_name = func.__name__
            tb = traceback.format_exc()
            raise VMError(
                f"Error calling built-in function {func_name}: {e} {tb}")
        return result

    @operator(Opcode.OP_GET_PROP)
    def exec_get_prop(self, obj: MOOAny, prop: MOOString) -> MOOAny:
        """Get the value of a property on an object"""

        object = self.db.objects.get(obj)
        if object is None:
            raise VMError("Object not found")
        property = object.get_prop(prop)
        if property is None:
            raise VMError("Property not found")
        return property.value

    @operator(Opcode.OP_PUT_PROP)
    def exec_put_prop(self, obj: MOOAny, prop: MOOString, value: MOOAny):
        """Set the value of a property on an object"""
        object = self.db.objects.get(obj)
        if object is None:
            raise VMError("Object not found")
        property = object.get_prop(prop)
        if property is None:
            raise VMError("Property not found")

        property.value = value
        return value
