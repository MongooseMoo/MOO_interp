import inspect
import traceback
import warnings
from enum import Enum
from functools import wraps
from logging import basicConfig, getLogger
from typing import Any, Callable, Dict, List, Mapping, Optional, Protocol, Tuple, Union, cast, overload

from attr import define, field
from lambdamoo_db.database import Anon, MooDatabase, ObjNum

from .builtin_functions import BuiltinFunctions
from .errors import ERROR_CODES, MOOError, MOOException, SuspendException, ExecSuspendException
from .list import MOOList
from .map import MOOMap
from .moo_types import (Addable, Comparable, Container, MapKey, MOOAny,
                        MOONumber, Subtractable, is_truthy)
from .opcodes import Extended_Opcode, Opcode, is_optim_num_opcode, opcode_to_optim_num
from .string import MOOString

# Type alias for primitive MOO values (not objects)
# These use prototype lookup for verb calls
MOOPrimitive = Union[int, float, str, MOOString, MOOError, MOOList, MOOMap]

# Type alias for all values that can be verb call targets
# Objects (ObjNum, Anon) call verbs directly; primitives use prototype lookup
MOOValue = Union[ObjNum, Anon, MOOPrimitive]


class OpcodeHandler(Protocol):
    """Protocol for opcode handler functions decorated with @operator.

    The @operator decorator adds these attributes at runtime.
    """
    opcode: Opcode | None
    eopcode: Extended_Opcode | None
    num_args: int

    def __call__(self, *args: Any) -> Any: ...

# basicConfig(level="DEBUG")
logger = getLogger(__name__)

""" LambdaMOO Virtual Machine

    This module implements the LambdaMOO Virtual Machine, which is
    responsible for executing the bytecode generated by the compiler.
    The VM is a stack machine with a single stack of values and a
    separate call stack.  The VM is also responsible for handling
    errors, which are represented by Python exceptions.
"""


class VMError(Exception):
    """Base class for all VM errors"""
    pass


class FinallyReason(Enum):
    FIN_FALL_THRU = 0
    FIN_RAISE = 1
    FIN_UNCAUGHT = 2
    FIN_RETURN = 3
    FIN_ABORT = 4
    FIN_EXIT = 5


class VMOutcome(Enum):
    OUTCOME_DONE = 0  # Task ran successfully to completion
    OUTCOME_ABORTED = 1  # Task aborted, either by kill_task or by an uncaught error
    OUTCOME_BLOCKED = 2  # Task called a blocking built-in function
    OUTCOME_FORKED = 3  # Task executed a fork opcode, child task needs to be created


@define
class Instruction:
    """Represents a single bytecode instruction"""
    opcode: Union[Opcode, int]
    operand: Optional[MOOAny | Extended_Opcode] = None
    label: Optional[int] = None
    loop_var: Optional[MOOString] = None # i
    loop_index: Optional[MOOString] = None # j
    jump_target: Optional[int] = None
    handler_offset: Optional[int] = None  # For try/except: offset to handler
    error_codes: Optional[list] = None  # For try/except: list of error codes to catch
    error_vars: Optional[list] = None  # For try/except: variable names to bind error to
    scatter_pattern: Optional[list] = None  # For EOP_SCATTER: list of (var_name, is_rest) tuples

@define
class Program:
    first_lineno: int = field(default=1)
    literals: List[Any] = field(factory=list)
    fork_vectors: List[int] = field(factory=list)
    var_names: List[MOOString] = field(factory=list)


@define
class StackFrame:
    """Represents a single frame in the call stack"""
    func_id: int
    prog: Program
    ip: int
    stack: List[Any] = field(factory=list)
    rt_env: List[Any] = field(factory=list)
    bf_ip: int = field(default=0)
    temp: Optional[int] = field(default=0)
    this: Any = field(default=0)  # int for object calls, primitive value for prototype calls
    player: int = field(default=0)
    verb: str = field(default="")
    verb_name: str = field(default="")
    debug: bool = field(default=False)
    threaded: bool = field(default=False)
    loop_stack: List[Any] = field(factory=list)  # Stack for loop state tracking
    exception_stack: List[Any] = field(factory=list)  # Stack for exception handlers
    stack_base: int = field(default=0)  # VM stack position when frame started
    caller_perms: Optional[int] = None  # Object ID whose permissions apply (None = use player)
    definer: Optional[int] = None  # Object ID where verb was defined (for pass())

    @property
    def current_instruction(self) -> Instruction:
        """The current instruction"""       
        return self.stack[self.ip]

def operator(opcode):
    """Operator decorator.
    """
    def decorator(func):
        sig = inspect.signature(func)
        func_params = list(sig.parameters.values())[1:]  # Skip 'self'

        num_args = len(func_params)

        unannotated_params = [
            param.name for param in func_params if param.annotation is inspect._empty]

        if unannotated_params:
            warnings.warn(
                f"Parameter(s) {', '.join(unannotated_params)} of {func.__name__} are not annotated, will be considered as 'Any'")

        def typecheck(args, func_params):
            for arg, param in zip(args, func_params):
                if param.annotation in {inspect._empty, Any}:
                    continue
                if not isinstance(arg, param.annotation):
                    # Raise E_TYPE for type mismatches so it's recognized as a MOO error
                    raise MOOException(MOOError.E_TYPE)

        @wraps(func)
        def wrapper(self, *args):
            # Check for stack underflow
            # Skip check for opcodes that get args from instruction operand, not stack
            operand_from_instruction = {Opcode.OP_PUSH, Opcode.OP_IMM, Opcode.OP_PUT, Opcode.OP_POP,
                                        Opcode.OP_JUMP, Opcode.OP_WHILE, Opcode.OP_IF, Opcode.OP_EIF, Opcode.OP_IF_QUES,
                                        Opcode.OP_G_PUSH, Opcode.OP_G_PUT, Opcode.OP_G_PUSH_CLEAR,
                                        Opcode.OP_FORK, Opcode.OP_FORK_WITH_ID}
            if isinstance(opcode, Opcode) and opcode not in operand_from_instruction:
                if len(self.stack) < num_args:
                    raise VMError(
                        f"Stack underflow in opcode {opcode} in function {func.__name__}")

                typecheck(self.stack[-num_args:], func_params)
            # Call the function
            return func(self, *args)

        # Store the opcode and number of arguments on the function itself
        # Always set both attributes (Protocol requires them both to exist)
        wrapper.opcode = opcode if isinstance(opcode, Opcode) else None  # type: ignore[attr-defined]
        wrapper.eopcode = opcode if isinstance(opcode, Extended_Opcode) else None  # type: ignore[attr-defined]
        wrapper.num_args = num_args  # type: ignore[attr-defined]

        return wrapper
    return decorator


@define
class VM:
    """The virtual machine"""

    stack: List[Any] = field(factory=list)
    call_stack: List[StackFrame] = field(factory=list)
    result: MOOAny = field(default=0)
    state: Union[VMOutcome, None] = field(default=None)
    # int is included for OPTIM_NUM opcodes (optimized immediate numbers)
    opcode_handlers: Dict[Opcode | Extended_Opcode | int, OpcodeHandler] = field(factory=dict, repr=False)
    db: Optional[MooDatabase] = field(default=None)
    bi_funcs: BuiltinFunctions = field(factory=BuiltinFunctions, repr=False)
    # Suspend info - set when a builtin raises SuspendException
    suspend_seconds: float = field(default=0.0)
    # Exec info - set when a builtin raises ExecSuspendException
    # Contains: process (Popen), stdin_bytes, display_cmd
    exec_info: Optional[dict] = field(default=None)
    # Fork info - set when OP_FORK or OP_FORK_WITH_ID is executed
    fork_info: Optional[dict] = field(default=None)

    def __init__(self, db=None, bi_funcs=None):
        super().__init__()
        self.stack = []
        self.call_stack = []
        self.result = 0
        self.state = None
        self.opcode_handlers = {}
        self.bi_funcs = bi_funcs if bi_funcs else BuiltinFunctions()
        self.db = db
        self.suspend_seconds = 0.0
        self.fork_info = None
        handled_opcodes = set()

        # Register all opcode handlers
        for name in dir(self):
            if not name.startswith('exec'):
                continue
            method = getattr(self, name, None)
            if method is not None and (hasattr(method, 'opcode') or hasattr(method, 'eopcode')):
                handler = cast(OpcodeHandler, method)
                opcode = handler.opcode if handler.opcode is not None else handler.eopcode
                if opcode is not None:
                    self.opcode_handlers[opcode] = handler
                    handled_opcodes.add(opcode)

        # Opcodes that don't need implementation (retired, sentinels, handled specially)
        ignored_opcodes = {
            Opcode.OP_FOR_LIST,      # Retired - replaced by EOP_FOR_LIST_1/2
            Opcode.OPTIM_NUM_START,  # Sentinel for optimized number range
            Opcode.Last_Opcode,      # Sentinel
        }
        ignored_eopcodes = {
            Extended_Opcode.Last_Extended_Opcode,  # Sentinel
        }

        # Set of all opcodes
        all_opcodes = set(Opcode) - ignored_opcodes
        unhandled_opcodes = all_opcodes - handled_opcodes

        if unhandled_opcodes:
            warnings.warn(
                f"The following {len(unhandled_opcodes)} opcodes are not implemented: {[opcode.name for opcode in unhandled_opcodes]}", UserWarning)

        # Set of all extended opcodes
        all_eopcodes = set(Extended_Opcode) - ignored_eopcodes
        unhandled_eopcodes = all_eopcodes - handled_opcodes

        if unhandled_eopcodes:
            warnings.warn(
                f"The following {len(unhandled_eopcodes)} extended opcodes are not implemented: {[opcode.name for opcode in unhandled_eopcodes]}", UserWarning)

    def push(self, value: MOOAny) -> None:
        """Push a value onto the stack"""
        self.stack.append(value)

    def pop(self) -> MOOAny:
        """Pop a value off the stack, converting dicts to MOOMap"""
        try:
            value = self.stack.pop()
            # Convert plain dicts to MOOMap
            if isinstance(value, dict) and not isinstance(value, MOOMap):
                value = MOOMap(value)
            return value
        except IndexError:
            raise VMError("Stack underflow")

    def peek(self) -> Any:
        """Peek at the top value on the stack"""
        try:
            return self.stack[-1]
        except IndexError:
            raise VMError("Stack underflow")

    def _require_db(self) -> MooDatabase:
        """Get the database, raising an error if not available.

        Use this instead of self.db when you need to access .objects
        to satisfy pyright's type narrowing.
        """
        if self.db is None:
            raise VMError("Database not available")
        return self.db

    def run(self):
        """Run the program"""
        # Give builtins access to VM context (for eval, callers, etc.)
        if hasattr(self.bi_funcs, '_vm'):
            self.bi_funcs._vm = self
        while self.state is None:
            self.step()
            yield self.stack

    @property
    def current_frame(self) -> StackFrame:
        """The current stack frame"""
        try:
            return self.call_stack[-1]
        except IndexError:
            raise VMError("No current stack frame")

    def step(self) -> None:
        """Execute the next instruction in the current stack frame."""
        if not self.call_stack:
            return

        frame = self.current_frame

        if frame.ip >= len(frame.stack):
            # Frame has no more instructions - pop it and finish or continue
            self.call_stack.pop()
            if self.call_stack:
                # There are more frames - continue execution
                return
            else:
                # This was the last frame - get result from VM stack if available
                self.result = self.stack[-1] if self.stack else 0
                self.state = VMOutcome.OUTCOME_DONE
                return
        result = None
        instr = frame.current_instruction
        handler = self.opcode_handlers.get(instr.opcode)
        if not handler:
            # Handle extended opcode
            if instr.opcode == Opcode.OP_EXTENDED:
                handler = self.opcode_handlers.get(
                    Extended_Opcode(instr.operand))
                if not handler:
                    raise VMError(f"Unknown extended opcode {instr.operand}")
            if not handler:
                # Check if it's an OPTIM_NUM opcode (optimized immediate number)
                if type(instr.opcode) == int and is_optim_num_opcode(instr.opcode):
                    result = opcode_to_optim_num(instr.opcode)
                else:
                    raise VMError(f"Unknown opcode {instr.opcode}")
        if result is None:
            logger.debug(f"Executing {instr.opcode} {instr.operand}")
            args = []
            if instr.opcode in {Opcode.OP_PUSH, Opcode.OP_PUT, Opcode.OP_IMM, Opcode.OP_POP, Opcode.OP_JUMP, Opcode.OP_WHILE, Opcode.OP_IF, Opcode.OP_EIF, Opcode.OP_IF_QUES, Opcode.OP_FORK, Opcode.OP_FORK_WITH_ID}:
                args = [instr.operand]
            elif handler is not None and handler.num_args:
                # Check for stack underflow (especially for Extended_Opcodes which skip the decorator check)
                if len(self.stack) < handler.num_args:
                    raise MOOException(MOOError.E_RANGE, f"Stack underflow: need {handler.num_args} args, have {len(self.stack)}")
                # Convert any dicts to MOOMap when getting args
                args = [MOOMap(v) if isinstance(v, dict) and not isinstance(v, MOOMap) else v
                        for v in self.stack[-handler.num_args:]]

            logger.debug(f"Args: {args}")

            try:
                if handler is not None:
                    result = handler(*args)

                    # Don't auto-pop args for opcodes that get args from operand (not stack)
                    # or for OP_POP which handles its own popping
                    if handler.num_args and instr.opcode not in {Opcode.OP_PUSH, Opcode.OP_IMM, Opcode.OP_JUMP, Opcode.OP_IF, Opcode.OP_EIF, Opcode.OP_IF_QUES, Opcode.OP_WHILE, Opcode.OP_POP}:
                        del self.stack[-handler.num_args:]
            except ExecSuspendException as e:
                # exec() builtin - save process info and block
                # Clean up args from stack (since handler didn't complete normally)
                if handler is not None and handler.num_args and instr.opcode not in {Opcode.OP_PUSH, Opcode.OP_IMM, Opcode.OP_JUMP, Opcode.OP_IF, Opcode.OP_EIF, Opcode.OP_IF_QUES, Opcode.OP_WHILE, Opcode.OP_POP}:
                    del self.stack[-handler.num_args:]
                self.suspend_seconds = 0
                self.exec_info = {
                    'process': e.process,
                    'stdin_bytes': e.stdin_bytes,
                    'display_cmd': e.display_cmd,
                }
                self.state = VMOutcome.OUTCOME_BLOCKED
                # Advance IP so we resume AFTER the exec() call
                # The resume value pushed onto stack will be the return value
                frame.ip += 1
                return  # Stop execution, task scheduler will poll process
            except SuspendException as e:
                # Blocking builtin (suspend, read, etc.) - save state and block
                # Clean up args from stack (since handler didn't complete normally)
                if handler is not None and handler.num_args and instr.opcode not in {Opcode.OP_PUSH, Opcode.OP_IMM, Opcode.OP_JUMP, Opcode.OP_IF, Opcode.OP_EIF, Opcode.OP_IF_QUES, Opcode.OP_WHILE, Opcode.OP_POP}:
                    del self.stack[-handler.num_args:]
                self.suspend_seconds = e.seconds
                self.state = VMOutcome.OUTCOME_BLOCKED
                # Advance IP so we resume AFTER the suspend() call
                # The resume value pushed onto stack will be the return value
                frame.ip += 1
                return  # Stop execution, task scheduler will resume later
            except (VMError, Exception) as e:
                # Check for exception handlers
                error_type = self._extract_error_type(e)
                if self._handle_exception(error_type, e):
                    return  # Exception was handled, continue execution
                # If it's a MOOException and not handled, re-raise it directly
                # so the error code is preserved
                if isinstance(e, MOOException):
                    raise
                raise VMError(f"Error executing opcode: {e}")

        # Push result if we have one (either from handler or from int opcode)
        if result is not None:
            self.push(result)
        frame.ip += 1

    def _extract_error_type(self, e: Exception) -> str:
        """Extract the MOO error type from an exception."""
        # Handle MOOException directly
        if isinstance(e, MOOException):
            error_code = e.error_code
            if hasattr(error_code, 'name'):
                return error_code.name
            # Map error code numbers to names
            error_names = {0: 'E_NONE', 1: 'E_TYPE', 2: 'E_DIV', 3: 'E_PERM',
                           4: 'E_PROPNF', 5: 'E_VERBNF', 6: 'E_VARNF', 7: 'E_INVIND',
                           8: 'E_RECMOVE', 9: 'E_MAXREC', 10: 'E_RANGE', 11: 'E_ARGS',
                           12: 'E_NACC', 13: 'E_INVARG', 14: 'E_QUOTA', 15: 'E_FLOAT'}
            return error_names.get(int(error_code), 'E_NONE')

        error_str = str(e)
        # Look for MOO error codes like E_DIV, E_TYPE, E_RANGE, etc.
        if 'E_DIV' in error_str or 'division' in error_str.lower() or 'by zero' in error_str.lower():
            return 'E_DIV'
        if 'E_TYPE' in error_str or 'type' in error_str.lower() or 'subscriptable' in error_str.lower() or 'not iterable' in error_str.lower():
            return 'E_TYPE'
        if 'E_RANGE' in error_str or 'index' in error_str.lower():
            return 'E_RANGE'
        if 'E_INVIND' in error_str:
            return 'E_INVIND'
        if 'E_PROPNF' in error_str:
            return 'E_PROPNF'
        if 'E_VERBNF' in error_str:
            return 'E_VERBNF'
        if 'E_PERM' in error_str:
            return 'E_PERM'
        if 'E_ARGS' in error_str:
            return 'E_ARGS'
        return 'E_NONE'  # Generic error

    def _handle_exception(self, error_type: str, exception: Exception) -> bool:
        """Check if there's an exception handler that can catch this error.

        Returns True if exception was handled, False otherwise.
        """
        frame = self.current_frame
        if not frame.exception_stack:
            return False

        # Look for a matching handler (search from top of stack)
        for i in range(len(frame.exception_stack) - 1, -1, -1):
            handler = frame.exception_stack[i]
            handler_type = handler['type']

            if handler_type in ('except', 'catch'):
                error_codes = handler['error_codes']
                # Check if this handler catches this error type
                if 'ANY' in error_codes or error_type in error_codes:
                    # Found a matching handler - jump to it
                    handler_ip = handler['handler_ip']
                    frame.ip = handler_ip  # Set directly, step() returns without incrementing
                    # Pop this handler and any handlers above it
                    frame.exception_stack = frame.exception_stack[:i]

                    if handler_type == 'except':
                        # Bind error to variable if specified
                        error_vars = handler.get('error_vars', [])
                        if error_vars:
                            error_var = error_vars[0] if error_vars else None
                            if error_var:
                                var_name = MOOString(error_var)
                                if var_name not in frame.prog.var_names:
                                    frame.prog.var_names.append(var_name)
                                    frame.rt_env.append(None)
                                var_index = frame.prog.var_names.index(var_name)
                                frame.rt_env[var_index] = error_type
                    elif handler_type == 'catch':
                        # Restore stack to depth when catch was set up
                        # This removes any intermediate values from the failed expression
                        stack_depth = handler.get('stack_depth', len(self.stack))
                        if len(self.stack) > stack_depth:
                            del self.stack[stack_depth:]
                        # For catch expressions, push error tuple onto stack
                        # The handler will pop this and replace with default value
                        self.push([error_type, str(exception), []])
                    return True
        return False

    # Basic opcode implementations
    @operator(Opcode.OP_JUMP)
    def exec_jump(self, offset: int):
        """Jumps to a different instruction in the bytecode.

        Args:
            offset (int): The label or offset to jump to.
        """
        # -1 to account for step()'s automatic ip += 1 at end
        self.current_frame.ip += offset - 1

    @operator(Opcode.OP_FORK)
    def exec_fork(self, f_index: int):
        """Fork statement - creates a new task to execute the fork body.

        Args:
            f_index (int): Index into fork_vectors for the fork body bytecode.
        """
        delay = self.pop()  # Seconds to delay before fork executes
        frame = self.current_frame

        # Store fork info for TaskRunner to create child task
        self.fork_info = {
            'f_index': f_index,
            'delay': float(delay),
            'fork_vector': frame.prog.fork_vectors[f_index],
            'rt_env': list(frame.rt_env),  # Copy of runtime environment
            'var_names': frame.prog.var_names,
            'this': frame.this,
            'player': frame.player,
        }
        self.state = VMOutcome.OUTCOME_FORKED
        return None

    @operator(Opcode.OP_FORK_WITH_ID)
    def exec_fork_with_id(self, operand: tuple):
        """Fork statement with ID - creates task and stores ID in variable.

        Args:
            operand: Tuple of (f_index, var_index) where var_index is the
                     variable to store the new task ID in.
        """
        f_index, var_index = operand
        delay = self.pop()  # Seconds to delay before fork executes
        frame = self.current_frame

        # Store fork info for TaskRunner to create child task
        self.fork_info = {
            'f_index': f_index,
            'delay': float(delay),
            'fork_vector': frame.prog.fork_vectors[f_index],
            'rt_env': list(frame.rt_env),  # Copy of runtime environment
            'var_names': frame.prog.var_names,
            'var_index': var_index,  # Variable to store task ID
            'this': frame.this,
            'player': frame.player,
        }
        self.state = VMOutcome.OUTCOME_FORKED
        return None

    def read_bytes(self, num_bytes: int) -> int:
        """Reads the given number of bytes from the bytecode.

        Args:
            num_bytes (int): The number of bytes to read.

        Returns:
            int: The value represented by the read bytes.
        """
        frame = self.call_stack[-1]  # get current stack frame
        # slice the bytecode from ip to ip + num_bytes and interpret it as an integer
        value = int.from_bytes(
            frame.stack[frame.ip:frame.ip + num_bytes], 'big')
        frame.ip += num_bytes  # increment ip by num_bytes
        return value

    @operator(Opcode.OP_PUSH)
    def exec_push(self, var_name: MOOString):
        """Pushes a value onto the stack.

        Args:
            var_name (str): The name of the variable to push.
        """
        frame = self.current_frame
        # get the index of the variable in the variable names list
        try:
            var_index = frame.prog.var_names.index(var_name)
            # push the value at the same index in the runtime environment
            result = frame.rt_env[var_index]
            logger.debug(f"Pushing {result} onto the stack from {var_name}")
            return result
        except ValueError:
            # Variable not in frame - check if it's a built-in error code
            var_str = str(var_name)
            if var_str in ERROR_CODES:
                return ERROR_CODES[var_str]
            raise

    @operator(Opcode.OP_PUSH_CLEAR)
    def exec_push_clear(self, var_name: MOOString):
        """ called the last time the variable is referenced in the program.

          Args:
            var_name (str): The name of the variable to push.
        """
        frame = self.current_frame
        # get the index of the variable in the variable names list
        var_index = frame.prog.var_names.index(var_name)
        # push the value at the same index in the runtime environment
        self.push(frame.rt_env[var_index])
        # clear the variable from the variable names list and the runtime environment
        frame.prog.var_names.pop(var_index)
        frame.rt_env.pop(var_index)

    @operator(Opcode.OP_PUSH_TEMP)
    def exec_push_temp(self):
        """Pushes the temporary value onto the stack."""
        val = self.current_frame.temp
        self.current_frame.temp = None
        logger.debug(f"Pushing {val} onto the stack from temp")
        return val

    @operator(Opcode.OP_IMM)
    def exec_imm(self, value: MOOAny):
        """Pushes an immediate value onto the stack.

        Args:
            value (Any): The value to push.
        """
        if isinstance(value, str):
            value = MOOString(value)
        return value

    @operator(Opcode.OP_POP)
    def exec_pop(self, num: int = 1):
        for _ in range(num):
            self.pop()

    @operator(Opcode.OP_PUT)
    def exec_put(self, identifier: MOOString):
        return self.put(identifier, self.peek())

    @operator(Opcode.OP_PUT_TEMP)
    def exec_put_temp(self) -> None:
        self.current_frame.temp = self.peek()

    def put(self, identifier: MOOString, value: MOOAny) -> MOOAny:
        """Puts a value into the current stack frame's scope.

        Args:
            identifier (str): The identifier to store the value under.
            value (MOOAny): The value to store.
        """
        frame = self.current_frame
        try:
            index = frame.prog.var_names.index(identifier)
        except ValueError:
            frame.prog.var_names.append(identifier)
            frame.rt_env.append(value)
            logger.debug(f"Put {value} into {identifier}")
            return value
        frame.rt_env[index] = value
        frame.rt_env.append(value)
        logger.debug(f"Put {value} into {identifier}")
        return value

    @operator(Opcode.OP_ADD)
    def exec_add(self, op1: Any, op2: Any) -> Any:
        # MOO is dynamically typed - incompatible types raise E_TYPE at runtime
        return op1 + op2

    @operator(Opcode.OP_MINUS)
    def exec_subtract(self, op1: Any, op2: Any) -> Any:
        # MOO is dynamically typed - incompatible types raise E_TYPE at runtime
        return op1 - op2

    @operator(Opcode.OP_MULT)
    def exec_multiply(self, op1: MOONumber, op2: MOONumber) -> MOONumber:
        return op1 * op2

    @operator(Opcode.OP_DIV)
    def exec_divide(self, op1: MOONumber, op2: MOONumber) -> MOONumber:
        try:
            # MOO semantics: integer / integer = integer (truncate toward zero)
            if isinstance(op1, int) and isinstance(op2, int):
                return op1 // op2  # Integer division
            else:
                return op1 / op2  # Float division
        except ZeroDivisionError:
            raise MOOException(MOOError.E_DIV, "Division by zero")

    @operator(Opcode.OP_MOD)
    def exec_mod(self, op1: MOONumber, op2: MOONumber) -> MOONumber:
        try:
            return op1 % op2
        except ZeroDivisionError:
            raise MOOException(MOOError.E_DIV, "Division by zero")

    @operator(Opcode.OP_EQ)
    def exec_eq(self, op1: MOOAny, op2: MOOAny) -> bool:
        """MOO equality: types must match (except bool==int cross-compare)."""
        return self._moo_equality(op1, op2)

    def _moo_equality(self, lhs: MOOAny, rhs: MOOAny) -> bool:
        """MOO strict type equality.

        In MOO, 1 == 1.0 is false because int != float.
        String comparison is case-insensitive.
        Only exception: bool and int can be compared across types.
        """
        lhs_type = type(lhs)
        rhs_type = type(rhs)

        # Same type: compare values
        if lhs_type == rhs_type:
            if isinstance(lhs, MOOList) and isinstance(rhs, MOOList):
                return self._list_equal(lhs, rhs)
            if isinstance(lhs, MOOMap) and isinstance(rhs, MOOMap):
                return self._map_equal(lhs, rhs)
            # String comparison is case-insensitive in MOO
            if isinstance(lhs, (str, MOOString)):
                return str(lhs).lower() == str(rhs).lower()
            return lhs == rhs

        # MOOString vs str should be treated as same type
        if isinstance(lhs, (str, MOOString)) and isinstance(rhs, (str, MOOString)):
            return str(lhs).lower() == str(rhs).lower()

        # Cross-type bool==int comparison (MOO specific)
        if isinstance(lhs, bool) and isinstance(rhs, int) and not isinstance(rhs, bool):
            return (1 if lhs else 0) == rhs
        if isinstance(rhs, bool) and isinstance(lhs, int) and not isinstance(lhs, bool):
            return lhs == (1 if rhs else 0)

        # Different types: not equal
        return False

    def _list_equal(self, lhs: 'MOOList', rhs: 'MOOList') -> bool:
        """Compare two MOO lists element by element."""
        if len(lhs._list) != len(rhs._list):
            return False
        for a, b in zip(lhs._list, rhs._list):
            if not self._moo_equality(a, b):
                return False
        return True

    def _map_equal(self, lhs: 'MOOMap', rhs: 'MOOMap') -> bool:
        """Compare two MOO maps with case-insensitive string keys."""
        if len(lhs._map) != len(rhs._map):
            return False
        # Build case-normalized key lookup for rhs
        rhs_normalized = {}
        for k, v in rhs._map.items():
            norm_k = str(k).lower() if isinstance(k, (str, MOOString)) else k
            rhs_normalized[norm_k] = (k, v)

        for k, v in lhs._map.items():
            norm_k = str(k).lower() if isinstance(k, (str, MOOString)) else k
            if norm_k not in rhs_normalized:
                return False
            rhs_k, rhs_v = rhs_normalized[norm_k]
            # Keys must have same type (but case-insensitive for strings)
            if not self._moo_equality(k, rhs_k):
                return False
            if not self._moo_equality(v, rhs_v):
                return False
        return True

    @operator(Opcode.OP_IN)
    def exec_in(self, lhs: MOOAny, rhs: Container) -> int:
        """Check if lhs is in rhs. Returns 1-based index or 0 if not found.

        For `x in list`: lhs=x, rhs=list - returns 1-based index of x in list
        For `x in string`: lhs=x, rhs=string - returns 1-based position
        For `x in map`: lhs=x, rhs=map - searches VALUES (case-insensitive for strings),
                        returns 1-based position of key in sorted order, or 0 if not found

        Stack order: push x, push container, OP_IN -> args=[x, container]
        So first param is lhs (value), second is rhs (container).
        """
        if isinstance(rhs, MOOList):
            # For lists, return 1-based index or 0
            # Must use MOO equality (case-insensitive for strings)
            for idx, item in enumerate(rhs._list):
                if self._moo_equality(lhs, item):
                    return idx + 1  # MOO uses 1-based indexing
            return 0
        elif isinstance(rhs, MOOString):
            # For strings, use case-insensitive find (MOO string comparison is case-insensitive)
            index = str(rhs).lower().find(str(lhs).lower())
            if index == -1:
                return 0
            return index + 1  # MOO uses 1-based indexing
        elif isinstance(rhs, MOOMap):
            # For maps: search VALUES (case-insensitive for strings)
            # Return 1-based position of key in sorted order, or 0 if not found
            lhs_lower = str(lhs).lower() if isinstance(lhs, (str, MOOString)) else None
            sorted_keys = list(rhs)  # __iter__ returns sorted keys

            for position, key in enumerate(sorted_keys, 1):
                value = rhs[key]
                if lhs_lower is not None and isinstance(value, (str, MOOString)):
                    # Case-insensitive string comparison
                    if str(value).lower() == lhs_lower:
                        return position
                elif value == lhs:
                    return position
            return 0
        else:
            # Try generic 'in' operator
            if lhs in rhs:
                return 1  # Just return truthy value
            return 0

    @operator(Opcode.OP_NE)
    def exec_ne(self, op1: MOOAny, op2: MOOAny) -> bool:
        return op1 != op2

    @operator(Opcode.OP_LT)
    def exec_lt(self, op1: Any, op2: Any) -> bool:
        # MOO is dynamically typed - incompatible types raise E_TYPE at runtime
        return op1 < op2

    @operator(Opcode.OP_LE)
    def exec_le(self, op1: Any, op2: Any) -> bool:
        # MOO is dynamically typed - incompatible types raise E_TYPE at runtime
        return op1 <= op2

    @operator(Opcode.OP_GT)
    def exec_gt(self, op1: Any, op2: Any) -> bool:
        # MOO is dynamically typed - incompatible types raise E_TYPE at runtime
        return op1 > op2

    @operator(Opcode.OP_GE)
    def exec_ge(self, op1: Any, op2: Any) -> bool:
        # MOO is dynamically typed - incompatible types raise E_TYPE at runtime
        return op1 >= op2

    @operator(Opcode.OP_AND)
    def exec_and(self, op1: Any, op2: Any) -> Any:
        # MOO `and` returns last truthy/falsy value (short-circuit), not boolean
        return op1 and op2

    @operator(Opcode.OP_OR)
    def exec_or(self, op1: Any, op2: Any) -> Any:
        # MOO `or` returns first truthy value or last falsy (short-circuit)
        return op1 or op2

    @operator(Opcode.OP_NOT)
    def exec_not(self, operand: MOOAny) -> bool:
        return not operand

    @operator(Opcode.OP_UNARY_MINUS)
    def exec_unary_minus(self, op1: MOONumber):
        return -op1

    # Extended opcode implementations

    @operator(Extended_Opcode.EOP_BITOR)
    def exec_bitor(self, op1: int, op2: int):
        return op1 | op2

    @operator(Extended_Opcode.EOP_BITAND)
    def exec_bitand(self, op1: int, op2: int) -> int:
        return op1 & op2

    @operator(Extended_Opcode.EOP_BITXOR)
    def exec_bitxor(self, op1: int, op2: int) -> int:
        return op1 ^ op2

    @operator(Extended_Opcode.EOP_BITSHL)
    def exec_bitshl(self, op1: int, op2: int) -> int:
        # MOO uses 64-bit integers
        if op2 < 0 or op2 > 64:
            raise MOOException(MOOError.E_INVARG)
        if op2 == 64:
            return 0
        if op2 == 0:
            return op1
        # Mask to 64-bit signed range
        result = op1 << op2
        # Wrap to signed 64-bit
        result = result & 0xFFFFFFFFFFFFFFFF
        if result >= 0x8000000000000000:
            result -= 0x10000000000000000
        return result

    @operator(Extended_Opcode.EOP_BITSHR)
    def exec_bitshr(self, op1: int, op2: int) -> int:
        # MOO uses 64-bit integers with logical (unsigned) right shift
        if op2 < 0 or op2 > 64:
            raise MOOException(MOOError.E_INVARG)
        if op2 == 64:
            return 0
        if op2 == 0:
            return op1
        # Convert to unsigned 64-bit, shift, then back to signed
        unsigned = op1 & 0xFFFFFFFFFFFFFFFF
        result = unsigned >> op2
        return result

    @operator(Extended_Opcode.EOP_EXP)
    def exec_exp(self, lhs: MOONumber,   rhs: MOONumber):
        return lhs ** rhs

    # List operations

    @operator(Opcode.OP_MAKE_EMPTY_LIST)
    def exec_make_empty_list(self) -> MOOList:
        return MOOList()

    @operator(Opcode.OP_LIST_ADD_TAIL)
    def exec_list_add_tail(self, lst: MOOList, tail: MOOAny) -> MOOList:
        if not isinstance(lst, MOOList):
            raise MOOException(MOOError.E_TYPE, "Expected list")
        lst.append(tail)
        return lst

    @operator(Opcode.OP_LIST_APPEND)  # extend in Python
    def exec_list_append(self, lst1: MOOList, lst2: MOOList) -> MOOList:
        if not isinstance(lst1, MOOList) or not isinstance(lst2, MOOList):
            raise MOOException(MOOError.E_TYPE, "Expected list")
        return lst1 + lst2

    @operator(Opcode.OP_MAKE_SINGLETON_LIST)
    def exec_make_singleton_list(self, value: MOOAny) -> MOOList:
        # Create a list containing just this one value
        # Use internal _list directly to avoid constructor unwrapping MOOLists
        result = MOOList()
        result._list = [value]
        return result

    @operator(Opcode.OP_CHECK_LIST_FOR_SPLICE)
    def exec_check_list_for_splice(self):
        if not isinstance(self.peek(), MOOList):
            raise MOOException(MOOError.E_TYPE, "Expected list")

    @operator(Opcode.OP_REF)
    def exec_ref(self, lst: Container, index: Any) -> MOOAny:
        # For lists and strings: index must be int (1-based)
        # For maps: index can be any type (used as key) EXCEPT collections
        # In non-debug mode (like toaststunt), errors return error values instead of raising
        debug_mode = self.current_frame.debug if self.current_frame else True

        if isinstance(lst, MOOMap):
            # Collections (lists, maps) cannot be used as map keys
            if isinstance(index, (MOOList, MOOMap)):
                if debug_mode:
                    raise MOOException(MOOError.E_TYPE)
                return MOOError.E_TYPE
            # Map indexing: use key directly, return E_RANGE if not found
            try:
                return lst[index]
            except KeyError:
                if debug_mode:
                    raise MOOException(MOOError.E_RANGE)
                return MOOError.E_RANGE
        # For lists and strings: index must be int
        if isinstance(lst, (MOOList, list, MOOString, str)):
            # Check index type - must be int (but not bool, and not ObjNum)
            if not isinstance(index, int) or isinstance(index, bool) or type(index).__name__ == 'ObjNum':
                if debug_mode:
                    raise MOOException(MOOError.E_TYPE, "list/string index must be integer")
                return MOOError.E_TYPE
        # MOOString and MOOList already handle 1-based indexing in __getitem__
        # Plain Python lists (e.g., from database properties) need conversion
        try:
            if isinstance(lst, list) and not isinstance(lst, MOOList):
                return lst[index - 1]  # Convert 1-based to 0-based for plain lists
            return lst[index]
        except IndexError:
            if debug_mode:
                raise MOOException(MOOError.E_RANGE, "list/string index out of range")
            return MOOError.E_RANGE

    @operator(Opcode.OP_PUSH_REF)
    def exec_push_ref(self, lst: Container, index: Any) -> MOOAny:
        """Push a reference from a nested container with copy-on-write.

        This is used for nested assignments like x[1][1] = value.
        Stack before: [..., container, index]
        Stack after: [..., container_copy, index, element]

        The net effect is +1 items on stack (pop 2, push 3).
        This keeps the container and index on stack for the chain of OP_INDEXSET
        that will work back through the nested assignment.

        If container has refcount > 1, it's copied before indexing.
        """
        # The operator decorator has already popped lst and index from stack
        # We need to check if lst should be copied, then push lst, index, and result

        # Copy-on-write: if container has multiple references, copy it
        if isinstance(lst, (MOOList, MOOMap)):
            if lst.refcount() > 1:
                lst = lst.shallow_copy()

        # Now get the indexed element
        element = self.exec_ref(lst, index)

        # Push the (possibly copied) container, the index, then the element
        self.push(lst)
        self.push(index)
        return element

    @operator(Opcode.OP_RANGE_REF)
    def exec_range_ref(self, lst: Container, start: int, end: int) -> MOOAny:
        # MOO uses 1-based indexing, Python uses 0-based
        # MOO x[2..4] means elements 2, 3, 4 (inclusive)
        # Python slice [1:4] means indices 1, 2, 3 (exclusive end)
        #
        # Special case: x[n..n] returns the single element, not a sublist/substring
        # This is toaststunt/MOO behavior

        # Range bounds checking (like toaststunt)
        # For non-inverted ranges (start <= end): check all bounds
        # For inverted ranges (start > end): no bounds check (returns empty)
        if isinstance(lst, MOOString):
            lst_len = len(str(lst))
            if start <= end and (start <= 0 or start > lst_len or end <= 0 or end > lst_len):
                raise MOOException(MOOError.E_RANGE, "string range out of bounds")
        elif isinstance(lst, MOOList):
            lst_len = len(lst._list)
            if start <= end and (start <= 0 or start > lst_len or end <= 0 or end > lst_len):
                raise MOOException(MOOError.E_RANGE, "list range out of bounds")
        elif isinstance(lst, MOOMap):
            # Maps can't use collections as range keys
            if isinstance(start, (MOOList, MOOMap)) or isinstance(end, (MOOList, MOOMap)):
                raise MOOException(MOOError.E_TYPE, "map range keys cannot be collections")

        py_start = start - 1
        py_end = end  # end stays same because Python is exclusive

        if isinstance(lst, MOOString):
            # Single element range returns the character itself
            if start == end:
                return MOOString(str(lst)[py_start])
            return MOOString(str(lst)[py_start:py_end])
        elif isinstance(lst, MOOList):
            # Single element range returns the element itself
            if start == end:
                return lst._list[py_start]
            return MOOList(lst._list[py_start:py_end])
        else:
            # Map range: start and end are KEY values, not positions
            sorted_keys = list(lst)  # __iter__ returns sorted keys

            # Check if this is an inverted range using MOO comparison
            # Inverted ranges always return empty map (no key existence check)
            from .map import moo_compare
            rel = moo_compare(start, end)
            if rel > 0:
                # Inverted range: start > end in MOO sort order
                return MOOMap()

            # Find positions of start and end keys
            start_pos = None
            end_pos = None
            for i, key in enumerate(sorted_keys):
                if key == start:
                    start_pos = i
                if key == end:
                    end_pos = i

            # For non-inverted ranges, if either key not found, E_RANGE
            if start_pos is None or end_pos is None:
                raise MOOException(MOOError.E_RANGE, "key not found in map")

            # Build result from keys in range [start_pos..end_pos]
            result_items = []
            for i, key in enumerate(sorted_keys):
                if start_pos <= i <= end_pos:
                    result_items.append((key, lst[key]))

            # Single element range returns the value itself
            if start == end and result_items:
                return result_items[0][1]
            return MOOMap(_map=dict(result_items))

    # Map operations

    @operator(Opcode.OP_MAP_CREATE)
    def exec_make_empty_map(self) -> MOOMap:
        return MOOMap()

    @operator(Opcode.OP_MAP_INSERT)
    def exec_map_insert(self, mapping: MOOMap, value: Any, key: MapKey) -> MOOMap:
        if not isinstance(mapping, MOOMap):
            raise MOOException(MOOError.E_TYPE, "Expected map")
        mapping[key] = value
        return mapping

    # Return Operations

    @operator(Opcode.OP_RETURN)
    def exec_return(self, value: MOOAny) -> MOOAny:
        # Get stack_base before popping frame
        frame = self.current_frame
        stack_base = frame.stack_base

        # Pop the current frame
        self.call_stack.pop()

        # Clean up this frame's stack segment (everything above stack_base)
        # The 'value' arg was already read from stack, will be deleted by step()
        # We clean up any other values this frame pushed
        if len(self.stack) > stack_base + 1:  # +1 for the return value we read
            del self.stack[stack_base:-1]  # Keep only the return value at top

        # If there are more frames, push return value to the VM stack and continue
        # If this was the last frame, set result and mark as done
        if self.call_stack:
            # Return to caller - push return value onto VM stack for caller to use
            self.push(value)
            return None  # Don't push again
        else:
            # This was the top-level frame - we're done
            self.result = value
            self.state = VMOutcome.OUTCOME_DONE
            return None  # Don't push since we're done

    @operator(Opcode.OP_RETURN0)
    def exec_return0(self) -> int | None:
        # Get stack_base before popping frame
        frame = self.current_frame
        stack_base = frame.stack_base

        # Pop the current frame
        self.call_stack.pop()

        # Clean up this frame's stack segment (everything above stack_base)
        if len(self.stack) > stack_base:
            del self.stack[stack_base:]

        # If there are more frames, push 0 to the VM stack and continue
        # If this was the last frame, set result and mark as done
        if self.call_stack:
            self.push(0)
            return None
        else:
            self.result = 0
            self.state = VMOutcome.OUTCOME_DONE
            return None

    @operator(Opcode.OP_DONE)
    def exec_done(self):
        """Handle verb completion - return 0 to caller if in nested call."""
        # Pop the current frame
        self.call_stack.pop()

        # If there are more frames, push 0 to the VM stack and continue
        # If this was the last frame, mark as done
        if self.call_stack:
            self.push(0)
            return None  # Continue execution in caller
        else:
            self.result = 0
            self.state = VMOutcome.OUTCOME_DONE
            return None

    # Verb Call Operations

    @operator(Opcode.OP_CALL_VERB)
    def exec_call_verb(self, obj_id: MOOValue, verb_name: MOOString, args: MOOList):
        """Call a verb on an object

        Stack layout (bottom to top, popped in reverse):
        - obj_id: object ID to call verb on (popped last)
        - verb_name: name of verb to call (popped second)
        - args: MOOList of arguments to pass to verb (popped first)
        """
        logger.debug(f"CALL_VERB: #{obj_id}:{verb_name}({args})")
        if not self.db:
            raise VMError("No database available for verb calls")

        # Validate types
        if not isinstance(args, MOOList):
            raise VMError(f"OP_CALL_VERB: args must be MOOList, got {type(args)}")
        if not isinstance(verb_name, MOOString):
            raise VMError(f"OP_CALL_VERB: verb_name must be MOOString, got {type(verb_name).__name__}={repr(verb_name)}")

        # Handle primitive values - calling verbs on primitives uses prototype objects
        primitive_this: MOOValue | None = None  # Will hold the primitive value if calling on prototype

        if not isinstance(obj_id, (ObjNum, Anon)):
            # Primitive value (int, float, string, error, list, map)
            # Look up the corresponding prototype on #0
            proto_obj = self._get_primitive_prototype(obj_id)
            if proto_obj is None:
                raise MOOException(MOOError.E_TYPE, f"Cannot call verb on primitive value type={type(obj_id).__name__}")
            # Store the primitive for use as 'this', call verb on prototype
            primitive_this = obj_id
            obj_id = proto_obj

        # Find the object
        if obj_id not in self._require_db().objects:
            raise MOOException(MOOError.E_INVIND, f"Invalid object #{obj_id}")

        # Find verb on object or its parents (inheritance chain)
        verb = self._find_verb(obj_id, str(verb_name))
        if not verb:
            raise MOOException(MOOError.E_VERBNF, f"verb '{verb_name}' not found on object #{obj_id}")

        # Check if verb.code is already compiled bytecode (Instructions) or source strings
        # For tests: verb.code may be [Instruction, ...]
        # For real usage: verb.code is ["source line 1", "source line 2", ...]
        compiled_frame = None
        if verb.code and isinstance(verb.code[0], Instruction):
            # Already compiled - use directly
            bytecode = verb.code
        else:
            # Source code - compile it
            # Import here to avoid circular dependency
            from .moo_ast import parse, compile as compile_moo

            # MOO context variable names - pre-register at indices 0-10
            context_vars = [
                "player", "this", "caller", "verb", "args", "argstr",
                "dobj", "dobjstr", "iobj", "iobjstr", "prepstr"
            ]

            try:
                if verb.code is None:
                    raise VMError(f"OP_CALL_VERB: verb '{verb_name}' has no code")
                code_str = "\n".join(verb.code)
                ast = parse(code_str)
                # Use the VM's bi_funcs instance for consistent builtin IDs
                # Pass context_vars so they get pre-registered with stable indices
                compiled_frame = compile_moo(ast, bi_funcs=self.bi_funcs, context_vars=context_vars)
                bytecode = compiled_frame.stack
            except Exception as e:
                raise VMError(f"OP_CALL_VERB: failed to compile verb '{verb_name}': {e}")

        # Get current frame to copy context from
        caller_frame = self.current_frame if self.call_stack else None
        player_id = caller_frame.player if caller_frame else 0
        caller_id = caller_frame.this if caller_frame else 0

        # Get the compiled verb's var_names and rt_env (context vars already at 0-10)
        verb_var_names = compiled_frame.prog.var_names if compiled_frame else []
        verb_rt_env = compiled_frame.rt_env if compiled_frame else [0] * 11  # Space for context

        # Create new stack frame for the verb
        # stack_base: VM stack position after CALL_VERB args are popped
        # The 3 args (obj_id, verb_name, args) will be deleted after this handler returns
        # For primitive prototype calls, 'this' is the primitive value, not the prototype object
        this_value = primitive_this if primitive_this is not None else obj_id
        new_frame = StackFrame(
            func_id=verb.object,
            prog=Program(var_names=verb_var_names),  # Already has context vars at 0-10
            ip=0,
            stack=bytecode,
            this=this_value,
            player=player_id,
            verb=str(verb_name),
            verb_name=verb.name,
            stack_base=len(self.stack) - 3,  # Position after args removed
            caller_perms=verb.owner,  # Store verb owner for caller_perms() builtin
        )

        # Set up runtime environment - context vars at indices 0-10
        new_frame.rt_env = list(verb_rt_env)  # Copy to avoid mutation
        argstr = " ".join(str(a) for a in args._list) if args._list else ""
        new_frame.rt_env[0] = player_id              # player
        new_frame.rt_env[1] = this_value             # this (primitive value for prototype calls)
        new_frame.rt_env[2] = caller_id              # caller
        new_frame.rt_env[3] = MOOString(str(verb_name))  # verb
        new_frame.rt_env[4] = args                   # args
        new_frame.rt_env[5] = MOOString(argstr)      # argstr
        new_frame.rt_env[6] = -1                     # dobj
        new_frame.rt_env[7] = MOOString("")          # dobjstr
        new_frame.rt_env[8] = -1                     # iobj
        new_frame.rt_env[9] = MOOString("")          # iobjstr
        new_frame.rt_env[10] = MOOString("")         # prepstr

        # Push the new frame onto the call stack
        self.call_stack.append(new_frame)

        # Don't return a value - the verb will execute and eventually OP_RETURN
        return None

    def _get_primitive_prototype(self, value: MOOPrimitive) -> ObjNum | None:
        """Get the prototype object for a primitive value.

        MOO allows calling verbs on primitive values (int, float, string, etc.)
        by looking up a prototype object on #0 (the system object).

        For example, calling 123:foo() looks up #0.int_proto and calls
        the 'foo' verb on that object with 'this' set to 123.

        Args:
            value: The primitive value

        Returns:
            Object ID of the prototype, or None if no prototype exists
        """
        if self.db is None or 0 not in self.db.objects:
            return None

        # Map Python types to MOO prototype property names
        # Based on ToastStunt's MATCH_TYPE macro in execute.cc
        # Order matters: check subclasses before parent classes (MOOError before int)
        proto_name: str | None = None
        if isinstance(value, bool):
            # Booleans are ints in MOO, use int_proto
            proto_name = "int_proto"
        elif isinstance(value, MOOError):
            # Check MOOError before int since MOOError is an IntEnum
            proto_name = "err_proto"
        elif isinstance(value, int):
            proto_name = "int_proto"
        elif isinstance(value, float):
            proto_name = "float_proto"
        elif isinstance(value, MOOString):
            proto_name = "str_proto"
        elif isinstance(value, str):
            proto_name = "str_proto"
        elif isinstance(value, MOOList):
            proto_name = "list_proto"
        elif isinstance(value, MOOMap):
            proto_name = "map_proto"

        if proto_name is None:
            return None

        # Look up the prototype property on #0
        system_obj = self._require_db().objects[0]
        for prop in getattr(system_obj, 'properties', []):
            prop_name = getattr(prop, 'propertyName', getattr(prop, 'name', ''))
            if prop_name == proto_name:
                prop_value = getattr(prop, 'value', None)
                # Must be a valid object
                if isinstance(prop_value, ObjNum) and int(prop_value) in self._require_db().objects:
                    return prop_value
                elif isinstance(prop_value, int) and prop_value in self._require_db().objects:
                    return ObjNum(prop_value)
                break

        return None

    def _find_verb(self, obj_id: int, verb_name: str):
        """Find a verb on an object or its parents (inheritance)

        Args:
            obj_id: Object to search
            verb_name: Name of verb to find

        Returns:
            Verb object if found, None otherwise
        """
        visited = set()  # Prevent infinite loops in inheritance
        to_check = [obj_id]

        while to_check:
            current_id = to_check.pop(0)

            if current_id in visited or current_id not in self._require_db().objects:
                continue
            visited.add(current_id)

            obj = self._require_db().objects[current_id]

            # Check verbs on this object
            # MOO verbs can have multiple aliases separated by spaces
            for verb in obj.verbs:
                # Split verb name into aliases and check each
                verb_aliases = verb.name.split()
                for alias in verb_aliases:
                    if self._verb_matches(alias, verb_name):
                        return verb

            # Add parents to check list
            if hasattr(obj, 'parents') and obj.parents:
                to_check.extend(obj.parents)

        return None

    def _verb_matches(self, pattern: str, verb_name: str) -> bool:
        """Check if verb_name matches a MOO verb pattern.

        MOO verb patterns use * to indicate optional suffix.
        Example: "co*nnect" matches "co", "con", "conn", "conne", "connec", "connect"

        The pattern means: required prefix (before *) + optional suffix (after *)
        The verb_name must:
        1. Start with the required prefix
        2. Be a prefix of the full verb name (prefix + suffix)

        Args:
            pattern: Verb pattern, possibly with * wildcard
            verb_name: Verb name to match

        Returns:
            True if verb_name matches pattern
        """
        # Strip @ prefix (used for second-person commands like "@connect")
        if pattern.startswith('@'):
            if verb_name.startswith('@'):
                verb_name = verb_name[1:]
                pattern = pattern[1:]
            else:
                return False

        # Check for wildcard
        if '*' in pattern:
            prefix, suffix = pattern.split('*', 1)
            full_name = prefix + suffix

            # verb_name must start with required prefix
            if not verb_name.lower().startswith(prefix.lower()):
                return False

            # verb_name must be a prefix of the full verb name
            if not full_name.lower().startswith(verb_name.lower()):
                return False

            return True
        else:
            # Exact match (case-insensitive)
            return pattern.lower() == verb_name.lower()

    # Control Flow Operations

    @operator(Opcode.OP_IF)
    def exec_if(self, jump_to: int):
        """Jump if condition is FALSE (skip then-block)."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    @operator(Opcode.OP_EIF)
    def exec_eif(self, jump_to: int):
        """Jump if condition is FALSE (skip elif-block)."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    @operator(Opcode.OP_IF_QUES)  # ternary operator
    def exec_if_ques(self, jump_to: int):
        """Ternary operator - jump if condition is FALSE."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    @operator(Opcode.OP_WHILE)
    def exec_while(self, jump_to: int):
        """While loop - jump past body if condition is FALSE."""
        condition = self.pop()
        if not is_truthy(condition):
            self.call_stack[-1].ip += jump_to

    def _skip_to_end_of_for_loop(self, frame):
        """Skip past the loop body to the instruction after OP_JUMP.

        For nested loops, we need to find the JUMP that matches THIS loop,
        not an inner loop's JUMP. We do this by counting nesting depth.
        """
        search_ip = frame.ip + 1
        nesting_depth = 1  # We're inside this loop, looking for its end

        while search_ip < len(frame.stack):
            search_instr = frame.stack[search_ip]

            # Check for nested loop start (increases depth)
            if search_instr.opcode == Opcode.OP_FOR_RANGE:
                nesting_depth += 1
            elif search_instr.opcode == Opcode.OP_EXTENDED:
                # EOP_FOR_LIST_1 and EOP_FOR_LIST_2 are nested loops too
                if search_instr.operand in (Extended_Opcode.EOP_FOR_LIST_1, Extended_Opcode.EOP_FOR_LIST_2):
                    nesting_depth += 1

            # Check for loop end (decreases depth)
            if search_instr.opcode == Opcode.OP_JUMP and isinstance(search_instr.operand, int) and search_instr.operand < 0:
                nesting_depth -= 1
                if nesting_depth == 0:
                    # Found our loop's JUMP
                    frame.ip = search_ip  # Will be incremented by step() to skip past JUMP
                    return

            search_ip += 1

    @operator(Opcode.OP_FOR_RANGE)
    def exec_for_range(self) -> None:
        """For-range loop: for i in [start..end]
        Loop state stored on frame.loop_stack as: ('range', ip, current, end)
        """
        frame = self.current_frame
        instr = frame.current_instruction
        loop_var = instr.loop_var
        if loop_var is None:
            raise VMError("FOR_RANGE requires a loop variable")

        # Check if we have existing loop state for this IP
        loop_index: int | None = None
        for i, entry in enumerate(frame.loop_stack):
            if len(entry) >= 2 and entry[0] == 'range' and entry[1] == frame.ip:
                loop_index = i
                break

        if loop_index is None:
            # First entry into loop
            to = self.pop()
            from_val = self.pop()
            if not isinstance(to, int) or not isinstance(from_val, int):
                self._skip_to_end_of_for_loop(frame)
                return
            if from_val > to:
                self._skip_to_end_of_for_loop(frame)
                return
            self.put(loop_var, from_val)
            frame.loop_stack.append(('range', frame.ip, from_val + 1, to))
        else:
            # Subsequent iteration
            _, _, current, to = frame.loop_stack[loop_index]
            if current > to:
                frame.loop_stack.pop(loop_index)
                self._skip_to_end_of_for_loop(frame)
                return
            self.put(loop_var, current)
            frame.loop_stack[loop_index] = ('range', frame.ip, current + 1, to)

    @operator(Extended_Opcode.EOP_FOR_LIST_1)
    def exec_for_list_1(self) -> None:
        """For-list loop: for x in (list|string|map)
        Loop state stored on frame.loop_stack as: ('list', ip, collection, iter_state)

        For strings: iterates over each character
        For lists: iterates over each element
        For maps: iterates over values only
        """
        frame = self.current_frame
        instr = frame.current_instruction
        loop_var = instr.loop_var
        if loop_var is None:
            raise VMError("FOR_LIST requires a loop variable")

        # Check if we have existing loop state for this IP
        loop_index: int | None = None
        for i, entry in enumerate(frame.loop_stack):
            if len(entry) >= 2 and entry[0] == 'list' and entry[1] == frame.ip:
                loop_index = i
                break

        if loop_index is None:
            # First entry into loop
            base_collection = self.pop()

            # Type check: must be string, list, or map
            # If it's an error value (from non-debug mode error), skip loop like toaststunt
            if isinstance(base_collection, MOOError):
                self._skip_to_end_of_for_loop(frame)
                return
            # Also check for error code integers that might slip through
            if isinstance(base_collection, int) and base_collection in (
                MOOError.E_NONE, MOOError.E_TYPE, MOOError.E_DIV, MOOError.E_PERM,
                MOOError.E_PROPNF, MOOError.E_VERBNF, MOOError.E_VARNF, MOOError.E_INVIND,
                MOOError.E_RECMOVE, MOOError.E_MAXREC, MOOError.E_RANGE, MOOError.E_ARGS,
                MOOError.E_NACC, MOOError.E_INVARG, MOOError.E_QUOTA, MOOError.E_FLOAT
            ):
                self._skip_to_end_of_for_loop(frame)
                return
            if not isinstance(base_collection, (MOOString, str, MOOList, MOOMap)):
                raise MOOException(MOOError.E_TYPE)

            # Check for empty collection
            if len(base_collection) == 0:
                self._skip_to_end_of_for_loop(frame)
                return

            # Get first element based on type
            if isinstance(base_collection, (MOOString, str)):
                # For strings: first character as MOOString
                self.put(loop_var, MOOString(str(base_collection)[0]))
                frame.loop_stack.append(('list', frame.ip, base_collection, 1))  # 0-based for strings
            elif isinstance(base_collection, MOOList):
                # For lists: first element (1-indexed)
                self.put(loop_var, base_collection[1])
                frame.loop_stack.append(('list', frame.ip, base_collection, 2))
            elif isinstance(base_collection, MOOMap):
                # For maps: first value only
                first_value = next(iter(base_collection.values()))
                self.put(loop_var, first_value)
                frame.loop_stack.append(('list', frame.ip, base_collection, 1))  # 0-based for maps
        else:
            # Subsequent iteration
            _, _, base_collection, iter_state = frame.loop_stack[loop_index]

            if isinstance(base_collection, (MOOString, str)):
                # String iteration: iter_state is 0-based index for next char
                if iter_state >= len(base_collection):
                    frame.loop_stack.pop(loop_index)
                    self._skip_to_end_of_for_loop(frame)
                    return
                self.put(loop_var, MOOString(str(base_collection)[iter_state]))
                frame.loop_stack[loop_index] = ('list', frame.ip, base_collection, iter_state + 1)
            elif isinstance(base_collection, MOOList):
                # List iteration: iter_state is 1-based index for next element
                if iter_state > len(base_collection):
                    frame.loop_stack.pop(loop_index)
                    self._skip_to_end_of_for_loop(frame)
                    return
                self.put(loop_var, base_collection[iter_state])
                frame.loop_stack[loop_index] = ('list', frame.ip, base_collection, iter_state + 1)
            elif isinstance(base_collection, MOOMap):
                # Map iteration: iter_state is 0-based index into values
                values_list = list(base_collection.values())
                if iter_state >= len(values_list):
                    frame.loop_stack.pop(loop_index)
                    self._skip_to_end_of_for_loop(frame)
                    return
                self.put(loop_var, values_list[iter_state])
                frame.loop_stack[loop_index] = ('list', frame.ip, base_collection, iter_state + 1)

    def _find_loop_end_jump(self, frame):
        """Find the backward JUMP that ends the current loop.

        Returns the IP of the JUMP instruction, or None if not found.
        Uses nesting depth to handle nested loops correctly.
        """
        search_ip = frame.ip + 1
        nesting_depth = 1  # We're inside this loop

        while search_ip < len(frame.stack):
            search_instr = frame.stack[search_ip]

            # Nested loop start increases depth
            if search_instr.opcode == Opcode.OP_FOR_RANGE:
                nesting_depth += 1
            elif search_instr.opcode == Opcode.OP_EXTENDED:
                if search_instr.operand in (Extended_Opcode.EOP_FOR_LIST_1, Extended_Opcode.EOP_FOR_LIST_2):
                    nesting_depth += 1
            elif search_instr.opcode == Opcode.OP_WHILE:
                nesting_depth += 1

            # Backward JUMP decreases depth
            if search_instr.opcode == Opcode.OP_JUMP and isinstance(search_instr.operand, int) and search_instr.operand < 0:
                nesting_depth -= 1
                if nesting_depth == 0:
                    return search_ip

            search_ip += 1
        return None

    @operator(Extended_Opcode.EOP_CONTINUE)
    def exec_continue(self):
        """Continue to next iteration of loop.

        Jump to the loop's ending JUMP instruction, which will then
        jump back to the loop header for the next iteration check.
        """
        frame = self.current_frame
        jump_ip = self._find_loop_end_jump(frame)
        if jump_ip is not None:
            # Set IP to one before the JUMP so step() increments to it
            frame.ip = jump_ip - 1
        return None

    @operator(Extended_Opcode.EOP_EXIT)
    def exec_exit(self):
        """Break out of loop (exit loop).

        Pop loop state and jump past the loop's ending JUMP.
        """
        frame = self.current_frame
        jump_ip = self._find_loop_end_jump(frame)
        if jump_ip is not None:
            # Pop loop_stack for FOR loops
            if frame.loop_stack:
                frame.loop_stack.pop()
            # Set IP to the JUMP; step() will increment past it
            frame.ip = jump_ip
        return None

    @operator(Extended_Opcode.EOP_LENGTH)
    def exec_length(self, value: MOOAny) -> int:
        """Return length of list, string, or map."""
        if isinstance(value, (MOOList, MOOMap)):
            return len(value)
        elif isinstance(value, (str, MOOString)):
            return len(value)
        else:
            raise MOOException(MOOError.E_TYPE, f"length() requires list, string, or map, got {type(value)}")

    @operator(Extended_Opcode.EOP_FIRST)
    def exec_first(self, lst: MOOList) -> MOOAny:
        """Return first element of list."""
        if not isinstance(lst, MOOList):
            raise MOOException(MOOError.E_TYPE, f"first() requires list, got {type(lst)}")
        if len(lst) == 0:
            raise MOOException(MOOError.E_RANGE, "first() on empty list")
        return lst[1]  # MOO is 1-indexed

    @operator(Extended_Opcode.EOP_LAST)
    def exec_last(self, lst: MOOList) -> MOOAny:
        """Return last element of list."""
        if not isinstance(lst, MOOList):
            raise MOOException(MOOError.E_TYPE, f"last() requires list, got {type(lst)}")
        if len(lst) == 0:
            raise MOOException(MOOError.E_RANGE, "last() on empty list")
        return lst[len(lst)]  # MOO is 1-indexed

    @operator(Extended_Opcode.EOP_FIRST_INDEX)
    def exec_first_index(self, container: MOOAny) -> MOOAny:
        """Get the first index/key appropriate for the container type.

        - For lists/strings: returns 1 (first position)
        - For maps: returns the first key
        Raises E_RANGE for empty containers.
        """
        if isinstance(container, (MOOList, MOOString, str)):
            if len(container) == 0:
                raise MOOException(MOOError.E_RANGE)
            return 1
        elif isinstance(container, MOOMap):
            if len(container) == 0:
                raise MOOException(MOOError.E_RANGE)
            # Return first key
            return next(iter(container.keys()))
        else:
            raise MOOException(MOOError.E_TYPE, f"first index requires list, string, or map, got {type(container)}")

    @operator(Extended_Opcode.EOP_LAST_INDEX)
    def exec_last_index(self, container: MOOAny) -> MOOAny:
        """Get the last index/key appropriate for the container type.

        - For lists/strings: returns length (0 for empty)
        - For maps: returns the last key (or E_RANGE if empty)

        Note: For lists/strings, this returns 0 for empty containers. This is
        correct because:
        - x[$] on empty list compiles to: push x, EOP_LAST (returns 0), OP_REF
          The OP_REF with index 0 will raise E_RANGE (1-based indexing)
        - x[1..$] on empty list compiles to: push x, push 1, EOP_LAST (returns 0), OP_RANGE_REF
          The OP_RANGE_REF with range 1..0 returns empty list (inverted range)
        """
        if isinstance(container, (MOOList, MOOString, str)):
            # Return length (0 for empty) - let OP_REF handle E_RANGE if indexing
            return len(container)
        elif isinstance(container, MOOMap):
            if len(container) == 0:
                raise MOOException(MOOError.E_RANGE)
            # Return last key
            # Maps maintain insertion order in Python 3.7+
            return list(container.keys())[-1]
        else:
            raise MOOException(MOOError.E_TYPE, f"last index requires list, string, or map, got {type(container)}")

    @operator(Extended_Opcode.EOP_RANGESET)
    def exec_rangeset(self, base, start, end, value):
        """Replace elements in range [start..end] with value.

        For lists: standard range replacement
        For maps: replace keys in range [start..end] with value map's entries
        """
        if isinstance(base, MOOList):
            # List range set
            if not isinstance(start, int) or not isinstance(end, int):
                raise MOOException(MOOError.E_TYPE, "list range indices must be integers")
            if not isinstance(value, MOOList):
                raise MOOException(MOOError.E_TYPE, "list range set requires list value")
            # Range validation (like toaststunt)
            # Always check: start > len + 1 (can't start past end+1) and end < 0 (negative end)
            base_len = len(base._list)
            if start > base_len + 1 or end < 0:
                raise MOOException(MOOError.E_RANGE, "list range out of bounds")
            # Convert to 0-indexed for internal list operations
            result = MOOList(*base._list[:start-1], *value._list, *base._list[end:])
            return result
        elif isinstance(base, MOOMap):
            # Map range set - start and end are keys
            if not isinstance(value, MOOMap):
                raise MOOException(MOOError.E_TYPE, "map range set requires map value")
            # Maps can't use collections as range keys
            if isinstance(start, (MOOList, MOOMap)) or isinstance(end, (MOOList, MOOMap)):
                raise MOOException(MOOError.E_TYPE, "map range keys cannot be collections")

            # Get sorted keys
            sorted_keys = list(base)  # __iter__ returns sorted keys

            # Find positions of start and end keys
            start_pos = None
            end_pos = None
            for i, key in enumerate(sorted_keys):
                if key == start:
                    start_pos = i
                if key == end:
                    end_pos = i

            # Handle inverted ranges (start > end means insert between)
            if start_pos is not None and end_pos is not None and start_pos > end_pos:
                # Inverted range: insert without removing
                # Just merge the value map into base
                result = base.shallow_copy()
                for k, v in value.items():
                    result[k] = v
                return result

            # If either key not found, E_RANGE
            if start_pos is None or end_pos is None:
                raise MOOException(MOOError.E_RANGE, "key not found in map")

            # Create new map following toaststunt semantics:
            # 1. Entries before start from base
            # 2. All entries from value map
            # 3. Entries after end from base (these override value entries!)
            result = MOOMap()

            # Step 1: entries before start
            for i, key in enumerate(sorted_keys):
                if i < start_pos:
                    result[key] = base[key]

            # Step 2: all value entries
            for k, v in value.items():
                result[k] = v

            # Step 3: entries after end (override any matching value entries)
            for i, key in enumerate(sorted_keys):
                if i > end_pos:
                    result[key] = base[key]

            return result
        elif isinstance(base, (str, MOOString)):
            # String range set
            if not isinstance(start, int) or not isinstance(end, int):
                raise MOOException(MOOError.E_TYPE, "string range indices must be integers")
            if not isinstance(value, (str, MOOString)):
                raise MOOException(MOOError.E_TYPE, "string range set requires string value")

            base_str = str(base)
            value_str = str(value)
            base_len = len(base_str)

            # Range bounds checking (like toaststunt)
            if start > base_len + 1 or end < 0:
                raise MOOException(MOOError.E_RANGE, "string range out of bounds")

            # Build result: left + value + right
            # lenleft = from > 1 ? from - 1 : 0
            # lenright = base_len > to ? base_len - to : 0
            lenleft = start - 1 if start > 1 else 0
            lenright = base_len - end if base_len > end else 0

            result = base_str[:lenleft] + value_str + base_str[base_len - lenright:]
            return MOOString(result)
        else:
            raise MOOException(MOOError.E_TYPE, f"rangeset requires list, map, or string, got {type(base)}")

    @operator(Extended_Opcode.EOP_COMPLEMENT)
    def exec_complement(self, value: int) -> int:
        """Bitwise complement (~value)."""
        if not isinstance(value, int):
            raise MOOException(MOOError.E_TYPE, f"complement requires integer, got {type(value)}")
        return ~value

    @operator(Extended_Opcode.EOP_SCATTER)
    def exec_scatter(self, source_list: MOOList) -> MOOList:
        """Scatter assignment: {a, b, ?c = default, @rest} = list.

        Reads scatter_pattern from instruction to determine variable assignments.
        Pattern format: list of (var_name, is_optional, is_rest, default_bc) tuples
        Legacy format: list of (var_name, is_rest) tuples - for backwards compat
        """
        frame = self.current_frame
        instr = frame.current_instruction
        pattern = instr.scatter_pattern

        if pattern is None:
            # Fallback: scatter to all var_names in order
            pattern = [(str(name), False, False, None) for name in frame.prog.var_names]

        list_items = list(source_list._list) if hasattr(source_list, '_list') else list(source_list)
        list_idx = 0

        for item in pattern:
            # Support both formats
            if len(item) == 2:
                # Legacy: (var_name, is_rest)
                var_name, is_rest = item
                is_optional = False
                default_bc = None
            else:
                # New: (var_name, is_optional, is_rest, default_bc)
                var_name, is_optional, is_rest, default_bc = item

            var_name_moo = MOOString(var_name)
            if var_name_moo not in frame.prog.var_names:
                frame.prog.var_names.append(var_name_moo)
                frame.rt_env.append(0)  # Default to 0 for new vars
            var_index = frame.prog.var_names.index(var_name_moo)

            if is_rest:
                # Rest parameter gets remaining elements as a list
                frame.rt_env[var_index] = MOOList(*list_items[list_idx:])
                list_idx = len(list_items)
            elif list_idx < len(list_items):
                # Have a value - use it
                frame.rt_env[var_index] = list_items[list_idx]
                list_idx += 1
            elif is_optional:
                # No value but optional - use default
                if default_bc:
                    # Execute default bytecode to get value
                    # For simplicity, we'll evaluate constants directly
                    # Default is typically a simple literal
                    if default_bc and len(default_bc) == 1:
                        default_instr = default_bc[0]
                        # Handle short integer format: opcode 113+n means push n
                        if isinstance(default_instr.opcode, int) and 113 <= default_instr.opcode < 369:
                            frame.rt_env[var_index] = default_instr.opcode - 113
                        elif default_instr.opcode == Opcode.OP_IMM and default_instr.operand is not None:
                            frame.rt_env[var_index] = default_instr.operand
                        else:
                            frame.rt_env[var_index] = 0
                    else:
                        frame.rt_env[var_index] = 0
                else:
                    frame.rt_env[var_index] = 0  # MOO default for optional
            else:
                # Required but not enough elements - error
                raise MOOException(MOOError.E_ARGS, "Not enough elements in list for scatter")

        return source_list

    @operator(Opcode.OP_INDEXSET)
    def exec_indexset(self, container: MOOAny, index: MOOAny, value: MOOAny) -> MOOAny:
        """Set container[index] = value. Works for lists and maps.

        Returns the modified container (which may be a shallow copy if refcount > 1).
        """
        if isinstance(container, MOOList):
            # Index must be int (but not bool, and not ObjNum)
            if not isinstance(index, int) or isinstance(index, bool) or type(index).__name__ == 'ObjNum':
                raise MOOException(MOOError.E_TYPE, "list index must be integer")
            # Copy-on-write: if refcount > 1, make shallow copy before modifying
            if container.refcount() > 1:
                container = container.shallow_copy()
            # MOO lists are 1-indexed
            container[index] = value
            return container
        elif isinstance(container, MOOMap):
            # Collections (lists, maps) cannot be used as map keys
            if isinstance(index, (MOOList, MOOMap)):
                raise MOOException(MOOError.E_TYPE)
            # Copy-on-write: if refcount > 1, make shallow copy before modifying
            if container.refcount() > 1:
                container = container.shallow_copy()
            container[index] = value
            return container
        elif isinstance(container, MOOString):
            # Index must be int (but not bool, and not ObjNum)
            if not isinstance(index, int) or isinstance(index, bool) or type(index).__name__ == 'ObjNum':
                raise MOOException(MOOError.E_TYPE, "string index must be integer")
            container[index] = value
            return container
        else:
            raise MOOException(MOOError.E_TYPE, f"indexset requires list, map, or string, got {type(container)}")

    @operator(Opcode.OP_G_PUSH)
    def exec_g_push(self) -> MOOAny:
        """Push global variable value onto stack."""
        frame = self.current_frame
        var_name = frame.stack[frame.ip].operand
        var_index = frame.prog.var_names.index(var_name)
        return frame.rt_env[var_index]

    @operator(Opcode.OP_G_PUT)
    def exec_g_put(self, value: MOOAny) -> MOOAny:
        """Store value in global variable."""
        frame = self.current_frame
        var_name = frame.stack[frame.ip].operand
        var_index = frame.prog.var_names.index(var_name)
        frame.rt_env[var_index] = value
        return value

    @operator(Opcode.OP_G_PUSH_CLEAR)
    def exec_g_push_clear(self) -> MOOAny:
        """Push global variable value and clear the variable."""
        frame = self.current_frame
        var_name = frame.stack[frame.ip].operand
        var_index = frame.prog.var_names.index(var_name)
        value = frame.rt_env[var_index]
        # Remove the variable
        del frame.rt_env[var_index]
        frame.prog.var_names.remove(var_name)
        return value

    @operator(Opcode.OP_PUSH_GET_PROP)
    def exec_push_get_prop(self) -> MOOAny:
        """Get property value from object, keeping obj and propname on stack.

        C semantics: READS (doesn't pop) obj and propname from stack, then
        pushes property value. Stack goes from [obj, propname] to [obj, propname, propvalue].

        This is used for nested indexed assignment like: obj.prop[1] = value
        where we need to keep obj and propname on stack for the final OP_PUT_PROP.
        """
        from lambdamoo_db.database import Clear
        from .waif import Waif

        # Peek at stack without popping (C uses TOP_RT_VALUE and NEXT_TOP_RT_VALUE)
        if len(self.stack) < 2:
            raise VMError("OP_PUSH_GET_PROP: stack underflow, need obj and propname")
        prop_name = self.stack[-1]  # TOP - property name
        obj_id = self.stack[-2]     # NEXT_TOP - object id

        # Handle WAIF - delegate to exec_get_prop which knows how to handle WAIFs
        if isinstance(obj_id, Waif):
            return self.exec_get_prop(obj_id, prop_name)

        obj = self._require_db().objects.get(obj_id)
        if obj is None:
            raise MOOException(MOOError.E_INVIND, f"Invalid object #{obj_id}")

        # Search properties list for matching property name (with inheritance)
        prop_name_str = str(prop_name)
        current_obj = obj
        visited = set()

        while current_obj is not None:
            current_obj_id = getattr(current_obj, 'id', None)
            if current_obj_id in visited:
                break  # Prevent infinite loops
            visited.add(current_obj_id)

            for prop in getattr(current_obj, 'properties', []):
                if getattr(prop, 'propertyName', getattr(prop, 'name', '')) == prop_name_str:
                    value = prop.value

                    # Skip Clear values - they mean "inherited, check parent"
                    if isinstance(value, Clear):
                        break  # Break inner loop to move to parent

                    # Convert raw Python types to MOO types
                    if isinstance(value, str) and not isinstance(value, MOOString):
                        value = MOOString(value)
                    elif isinstance(value, list) and not isinstance(value, MOOList):
                        value = MOOList(value)
                    elif isinstance(value, dict) and not isinstance(value, MOOMap):
                        value = MOOMap(value)
                    return value  # This gets pushed, leaving obj and propname below

            # Move to parent
            parent_id = getattr(current_obj, 'parent', -1)
            if parent_id < 0:
                break
            current_obj = self._require_db().objects.get(parent_id)

        raise MOOException(MOOError.E_PROPNF, f"Property {prop_name} not found on #{obj_id}")

    @operator(Opcode.OP_BI_FUNC_CALL)
    def exec_bi_func_call(self, args: MOOList) -> MOOAny:
        frame = self.call_stack[-1]
        instr = frame.stack[frame.ip]
        func_id = instr.operand
        func = self.bi_funcs.get_function_by_id(func_id)
        if func is None:
            func_name = self.bi_funcs.get_function_name_by_id(func_id) if self.bi_funcs else None
            # Debug info
            verb_name = frame.verb_name if hasattr(frame, 'verb_name') else '<unknown>'
            raise VMError(f"Unknown built-in function id={func_id} name={func_name} in verb={verb_name} ip={frame.ip} instr={instr}")
        try:
            result = func(*args._list)
        except MOOException:
            # Let MOOException propagate to be caught by MOO try/except handlers
            raise
        except SuspendException:
            # Let SuspendException propagate to be caught by step() for blocking
            raise
        except Exception as e:
            func_name = func.__name__
            tb = traceback.format_exc()
            raise VMError(
                f"Error calling built-in function {func_name}: {e} {tb}")
        # MOO builtins always return a value; None becomes 0
        return result if result is not None else 0

    @operator(Opcode.OP_GET_PROP)
    def exec_get_prop(self, obj: Any, prop: MOOString) -> MOOAny:
        """Get the value of a property on an object.

        Handles:
        1. WAIF properties (owner, class, wizard, programmer, :prop)
        2. Special pseudo-properties (wizard, programmer, player, etc.)
        3. Regular properties with inheritance
        """
        from .waif import Waif

        # Handle WAIF property access
        if isinstance(obj, Waif):
            prop_name = str(prop)

            # Special waif pseudo-properties - some work even when invalid
            if prop_name == 'class':
                from lambdamoo_db.database import ObjNum
                # Return #-1 if waif is invalid (class was recycled)
                if not obj.is_valid():
                    return ObjNum(-1)
                return ObjNum(obj.get_class())

            # For other properties, invalid waif raises E_INVIND
            if not obj.is_valid():
                raise MOOException(MOOError.E_INVIND, "Invalid waif")

            if prop_name == 'owner':
                from lambdamoo_db.database import ObjNum
                return ObjNum(obj.get_owner())
            elif prop_name == 'wizard':
                return 0  # WAIFs are never wizards
            elif prop_name == 'programmer':
                return 0  # WAIFs are never programmers

            # Waif properties: accessed as w.data, defined on class as :data
            # Auto-prefix with : for property lookup
            colon_prop = prop_name if prop_name.startswith(':') else ':' + prop_name

            # First check waif's own value
            if colon_prop in obj.propvals:
                return obj.propvals[colon_prop]

            # Then check class object for default value
            class_obj = self._require_db().objects.get(obj.get_class())
            if class_obj is None:
                raise MOOException(MOOError.E_INVIND, f"Waif class object #{obj.get_class()} not found")

            # Search class for property definition
            from lambdamoo_db.database import Clear
            to_check = [class_obj]
            visited = set()

            while to_check:
                current_obj = to_check.pop(0)
                obj_id = getattr(current_obj, 'id', None)
                if obj_id in visited:
                    continue
                visited.add(obj_id)

                for p in getattr(current_obj, 'properties', []):
                    if getattr(p, 'propertyName', getattr(p, 'name', '')) == colon_prop:
                        value = p.value
                        if isinstance(value, Clear):
                            break  # Check parents
                        if isinstance(value, str) and not isinstance(value, MOOString):
                            value = MOOString(value)
                        elif isinstance(value, list) and not isinstance(value, MOOList):
                            value = MOOList(value)
                        elif isinstance(value, dict) and not isinstance(value, MOOMap):
                            value = MOOMap(value)
                        return value

                # Add parents to search
                parents = getattr(current_obj, 'parents', None)
                if parents:
                    for parent_id in parents:
                        if parent_id >= 0:
                            parent_obj = self._require_db().objects.get(parent_id)
                            if parent_obj:
                                to_check.append(parent_obj)

            raise MOOException(MOOError.E_PROPNF, f"Property '{prop_name}' not found on waif")

        if not isinstance(obj, int):
            raise MOOException(MOOError.E_TYPE, f"Object reference must be int, got {type(obj)}")
        moo_object = self._require_db().objects.get(obj)
        if moo_object is None:
            raise MOOException(MOOError.E_INVIND, f"Object #{int(obj)} not found")

        prop_name = str(prop)

        # Handle special pseudo-properties from object flags
        # MOO flags: bit 1=programmer, bit 2=wizard
        # Note: 'player' is NOT a built-in property in MOO - use is_player() builtin instead
        flags = getattr(moo_object, 'flags', 0)
        if prop_name == 'wizard':
            return 1 if (flags & 4) else 0
        elif prop_name == 'programmer':
            return 1 if (flags & 2) else 0
        elif prop_name == 'r':
            return 1 if (flags & 0x10) else 0  # readable (FLAG_READ = bit 4)
        elif prop_name == 'w':
            return 1 if (flags & 0x20) else 0  # writable (FLAG_WRITE = bit 5)
        elif prop_name == 'f':
            return 1 if (flags & 0x80) else 0  # fertile (FLAG_FERTILE = bit 7)
        elif prop_name == 'a':
            return 1 if (flags & 0x100) else 0  # anonymous (FLAG_ANONYMOUS = bit 8)

        # Handle special object attributes (not regular properties)
        from lambdamoo_db.database import ObjNum
        if prop_name == 'owner':
            return ObjNum(getattr(moo_object, 'owner', -1))
        elif prop_name == 'location':
            return ObjNum(getattr(moo_object, 'location', -1))
        elif prop_name == 'contents':
            contents = getattr(moo_object, 'contents', [])
            return MOOList([ObjNum(c) for c in contents] if contents else [])
        elif prop_name == 'name':
            return MOOString(getattr(moo_object, 'name', ''))

        # Search for property by name (with multi-inheritance support)
        # Use BFS through parent chain to find the property
        from lambdamoo_db.database import Clear
        to_check = [moo_object]
        visited = set()

        while to_check:
            current_obj = to_check.pop(0)
            obj_id = getattr(current_obj, 'id', None)
            if obj_id in visited:
                continue  # Prevent infinite loops
            visited.add(obj_id)

            # Check this object's properties
            found_clear = False
            for p in getattr(current_obj, 'properties', []):
                if getattr(p, 'propertyName', getattr(p, 'name', '')) == prop_name:
                    value = p.value

                    # Skip Clear values - they mean "inherited, check parent"
                    if isinstance(value, Clear):
                        found_clear = True
                        break  # Break inner loop to move to parents

                    # Convert raw Python types to MOO types
                    if isinstance(value, str) and not isinstance(value, MOOString):
                        value = MOOString(value)
                    elif isinstance(value, list) and not isinstance(value, MOOList):
                        value = MOOList(value)
                    elif isinstance(value, dict) and not isinstance(value, MOOMap):
                        value = MOOMap(value)
                    return value

            # Add parents to check queue (support both single and multi-parent)
            parents = getattr(current_obj, 'parents', None)
            if parents is None:
                # Fallback to single parent (legacy support)
                try:
                    parent_id = current_obj.parent
                    if parent_id >= 0:
                        parent_obj = self._require_db().objects.get(parent_id)
                        if parent_obj:
                            to_check.append(parent_obj)
                except Exception:
                    pass
            else:
                # Multi-parent support
                for parent_id in parents:
                    if parent_id >= 0:
                        parent_obj = self._require_db().objects.get(parent_id)
                        if parent_obj:
                            to_check.append(parent_obj)

        raise MOOException(MOOError.E_PROPNF, f"Property '{prop_name}' not found on #{obj}")

    @operator(Opcode.OP_PUT_PROP)
    def exec_put_prop(self, obj: Any, prop: MOOString, value: MOOAny) -> MOOAny:
        """Set the value of a property on an object.

        Handles:
        1. WAIF properties (owner, class, wizard, programmer are immutable; :prop allowed)
        2. Pseudo-properties for object flags (wizard, programmer, player, r, w, f, a)
        3. Special attributes (owner, name, location)
        4. Inherited properties with copy-on-write semantics
        """
        from .waif import Waif, refers_to_waif

        # Handle WAIF property set
        if isinstance(obj, Waif):
            if not obj.is_valid():
                raise MOOException(MOOError.E_INVIND, "Invalid waif")

            prop_name = str(prop)

            # Special waif pseudo-properties are immutable
            if prop_name in ('owner', 'class', 'wizard', 'programmer'):
                raise MOOException(MOOError.E_PERM, f"Cannot set waif.{prop_name}")

            # Waif properties: accessed as w.data, defined on class as :data
            # Auto-prefix with : for property lookup
            colon_prop = prop_name if prop_name.startswith(':') else ':' + prop_name

            # Check for self-reference (E_RECMOVE)
            if refers_to_waif(value, obj):
                raise MOOException(MOOError.E_RECMOVE, "Waif cannot contain reference to itself")

            # Verify property exists on class object
            class_obj = self._require_db().objects.get(obj.get_class())
            if class_obj is None:
                raise MOOException(MOOError.E_INVIND, f"Waif class object #{obj.get_class()} not found")

            # Search class for property definition
            from lambdamoo_db.database import Clear
            to_check = [class_obj]
            visited = set()
            prop_found = False

            while to_check and not prop_found:
                current_obj = to_check.pop(0)
                obj_id = getattr(current_obj, 'id', None)
                if obj_id in visited:
                    continue
                visited.add(obj_id)

                for p in getattr(current_obj, 'properties', []):
                    if getattr(p, 'propertyName', getattr(p, 'name', '')) == colon_prop:
                        prop_found = True
                        break

                if not prop_found:
                    # Add parents to search
                    parents = getattr(current_obj, 'parents', None)
                    if parents:
                        for parent_id in parents:
                            if parent_id >= 0:
                                parent_obj = self._require_db().objects.get(parent_id)
                                if parent_obj:
                                    to_check.append(parent_obj)

            if not prop_found:
                raise MOOException(MOOError.E_PROPNF, f"Property '{prop_name}' not defined on waif class")

            # Store value in waif's propvals (using colon-prefixed key)
            obj.propvals[colon_prop] = value
            return value

        if not isinstance(obj, int):
            raise MOOException(MOOError.E_TYPE, f"Object reference must be int, got {type(obj)}")
        moo_object = self._require_db().objects.get(obj)
        if moo_object is None:
            raise MOOException(MOOError.E_INVIND, f"Object #{int(obj)} not found")

        prop_name = str(prop)
        # Convert value to boolean for flag properties
        bool_val = bool(value) if not isinstance(value, int) else (value != 0)

        # Handle pseudo-properties for object flags
        # MOO flags: bit 0=player, bit 1=programmer, bit 2=wizard
        # bit 4=read, bit 5=write, bit 7=fertile, bit 8=anonymous
        if not hasattr(moo_object, 'flags'):
            moo_object.flags = 0

        # Helper to check if caller is a wizard
        def caller_is_wizard():
            frame = self.current_frame
            # Use caller_perms if set (for server hooks like do_login_command)
            # Otherwise fall back to player
            perms_id = getattr(frame, 'caller_perms', None)
            if perms_id is None:
                perms_id = getattr(frame, 'player', -1)
            if hasattr(perms_id, '__int__'):
                perms_id = int(perms_id)
            perms_obj = self._require_db().objects.get(perms_id)
            if perms_obj:
                perms_flags = getattr(perms_obj, 'flags', 0)
                return bool(perms_flags & 0x04)
            return False

        is_anon = getattr(moo_object, 'anon', False)

        if prop_name == 'wizard':
            # Only wizards can set wizard flag (check permission first)
            if not caller_is_wizard():
                raise MOOException(MOOError.E_PERM, "Only wizards can set wizard flag")
            # Anonymous objects cannot have wizard flag (check after permission)
            if is_anon:
                raise MOOException(MOOError.E_INVARG, "Cannot set wizard flag on anonymous object")
            if bool_val:
                moo_object.flags |= 0x04
            else:
                moo_object.flags &= ~0x04
            return value
        elif prop_name == 'programmer':
            # Only wizards can set programmer flag (check permission first)
            if not caller_is_wizard():
                raise MOOException(MOOError.E_PERM, "Only wizards can set programmer flag")
            # Anonymous objects cannot have programmer flag (check after permission)
            if is_anon:
                raise MOOException(MOOError.E_INVARG, "Cannot set programmer flag on anonymous object")
            if bool_val:
                moo_object.flags |= 0x02
            else:
                moo_object.flags &= ~0x02
            return value
        elif prop_name == 'player':
            # Anonymous objects cannot be players
            if is_anon:
                raise MOOException(MOOError.E_INVARG, "Cannot set player flag on anonymous object")
            if bool_val:
                moo_object.flags |= 0x01
            else:
                moo_object.flags &= ~0x01
            return value
        elif prop_name == 'r':
            if bool_val:
                moo_object.flags |= 0x10
            else:
                moo_object.flags &= ~0x10
            return value
        elif prop_name == 'w':
            if bool_val:
                moo_object.flags |= 0x20
            else:
                moo_object.flags &= ~0x20
            return value
        elif prop_name == 'f':
            if bool_val:
                moo_object.flags |= 0x80
            else:
                moo_object.flags &= ~0x80
            return value
        elif prop_name == 'a':
            if bool_val:
                moo_object.flags |= 0x100
            else:
                moo_object.flags &= ~0x100
            return value

        # Handle special object attributes (not regular properties)
        if prop_name == 'name':
            moo_object.name = str(value) if value is not None else ''
            return value
        elif prop_name == 'owner':
            # Only wizards can change object ownership
            if not caller_is_wizard():
                raise MOOException(MOOError.E_PERM, "Only wizards can change object ownership")
            if not isinstance(value, int):
                raise MOOException(MOOError.E_TYPE, "owner must be an object number")
            moo_object.owner = value
            return value
        elif prop_name == 'location':
            if not isinstance(value, int):
                raise MOOException(MOOError.E_TYPE, "location must be an object number")
            moo_object.location = value
            return value

        # First, check if property exists on this object directly
        for p in getattr(moo_object, 'properties', []):
            if getattr(p, 'propertyName', getattr(p, 'name', '')) == prop_name:
                p.value = value
                return value

        # Property not on object - check if it's inherited (multi-parent support)
        to_check = [moo_object]
        visited = set()
        inherited_prop = None

        while to_check and inherited_prop is None:
            current_obj = to_check.pop(0)
            obj_id = getattr(current_obj, 'id', None)
            if obj_id in visited:
                continue
            visited.add(obj_id)

            # Check this object's properties (skip the original object, already checked above)
            if current_obj is not moo_object:
                for p in getattr(current_obj, 'properties', []):
                    if getattr(p, 'propertyName', getattr(p, 'name', '')) == prop_name:
                        inherited_prop = p
                        break
            if inherited_prop:
                break

            # Add parents to check queue
            parents = getattr(current_obj, 'parents', None)
            if parents is None:
                # Fallback to single parent
                try:
                    parent_id = current_obj.parent
                    if parent_id >= 0:
                        parent_obj = self._require_db().objects.get(parent_id)
                        if parent_obj:
                            to_check.append(parent_obj)
                except Exception:
                    pass
            else:
                for parent_id in parents:
                    if parent_id >= 0:
                        parent_obj = self._require_db().objects.get(parent_id)
                        if parent_obj:
                            to_check.append(parent_obj)

        if inherited_prop is None:
            raise MOOException(MOOError.E_PROPNF, f"Property '{prop_name}' not found on #{obj}")

        # Create a local copy of the inherited property with the new value
        from lambdamoo_db.database import Property
        new_prop = Property(
            propertyName=prop_name,
            value=value,
            owner=getattr(inherited_prop, 'owner', 0),
            perms=getattr(inherited_prop, 'perms', 0)
        )
        if not hasattr(moo_object, 'properties'):
            moo_object.properties = []
        moo_object.properties.append(new_prop)
        return value

    @operator(Extended_Opcode.EOP_TRY_EXCEPT)
    def exec_try_except(self) -> None:
        """Start of try block - push exception handler onto stack."""
        frame = self.current_frame
        instr = frame.current_instruction
        # Store handler info: (handler_ip, error_codes, try_start_ip, error_vars)
        if instr.handler_offset is None:
            raise VMError("TRY_EXCEPT requires handler_offset")
        handler_ip = frame.ip + instr.handler_offset
        error_codes = instr.error_codes or ['ANY']
        error_vars = instr.error_vars or []
        frame.exception_stack.append({
            'type': 'except',
            'handler_ip': handler_ip,
            'error_codes': error_codes,
            'error_vars': error_vars,
            'try_start_ip': frame.ip
        })

    @operator(Extended_Opcode.EOP_END_EXCEPT)
    def exec_end_except(self) -> None:
        """End of except handler - pop the exception handler."""
        frame = self.current_frame
        if frame.exception_stack and frame.exception_stack[-1].get('type') == 'except':
            frame.exception_stack.pop()

    @operator(Extended_Opcode.EOP_TRY_FINALLY)
    def exec_try_finally(self) -> None:
        """Start of try/finally block - push finally handler onto stack."""
        frame = self.current_frame
        instr = frame.current_instruction
        # For try/finally, we need to know where the finally block starts
        # Store: (finally_ip, try_start_ip)
        # The finally block starts after EOP_END_FINALLY
        frame.exception_stack.append({
            'type': 'finally',
            'try_start_ip': frame.ip
        })

    @operator(Extended_Opcode.EOP_END_FINALLY)
    def exec_end_finally(self) -> None:
        """End of finally marker - pop the finally handler and execute finally block."""
        frame = self.current_frame
        if frame.exception_stack and frame.exception_stack[-1].get('type') == 'finally':
            frame.exception_stack.pop()

    @operator(Extended_Opcode.EOP_PUSH_LABEL)
    def exec_push_label(self) -> int:
        """Push a label offset onto the stack for catch/loop targeting."""
        frame = self.current_frame
        instr = frame.current_instruction
        # The label offset is in handler_offset field
        return instr.handler_offset if instr.handler_offset is not None else 0

    @operator(Extended_Opcode.EOP_CATCH)
    def exec_catch(self) -> None:
        """Set up catch handler for inline error catching (`expr ! codes').

        Stack before: [error_codes_list, handler_offset]
        Pops handler_offset and error_codes, sets up exception handler.
        """
        frame = self.current_frame
        instr = frame.current_instruction

        # Pop handler offset from stack (pushed by PUSH_LABEL)
        handler_offset = self.pop()
        if not isinstance(handler_offset, int):
            raise VMError("CATCH handler_offset must be int")
        # Pop error codes list from stack
        error_codes_from_stack = self.pop()

        # Use error codes from instruction or stack
        error_codes = instr.error_codes or error_codes_from_stack or ['ANY']

        # Calculate absolute handler IP
        handler_ip = frame.ip + handler_offset

        frame.exception_stack.append({
            'type': 'catch',
            'handler_ip': handler_ip,
            'error_codes': error_codes,
            'catch_start_ip': frame.ip,
            'stack_depth': len(self.stack)  # Save stack depth to restore on exception
        })

    @operator(Extended_Opcode.EOP_END_CATCH)
    def exec_end_catch(self) -> MOOAny:
        """End of inline catch expression.

        Pops the result value, pops the catch marker, then pushes the value back.
        Also jumps to skip the default value expression.
        """
        frame = self.current_frame
        instr = frame.current_instruction

        # Pop the expression result (if any)
        result = self.pop() if self.stack else 0

        # Pop catch marker from exception stack
        if frame.exception_stack and frame.exception_stack[-1].get('type') == 'catch':
            frame.exception_stack.pop()

        # Jump past the default expression - jump distance is in handler_offset
        if instr.handler_offset is not None:
            frame.ip += instr.handler_offset

        return result

    @operator(Extended_Opcode.EOP_WHILE_ID)
    def exec_while_id(self) -> None:
        """While loop with loop ID stored in a variable.

        Stores the loop ID in a variable before the while condition check.
        Used for named loops like: while foo (condition)
        """
        frame = self.current_frame
        instr = frame.current_instruction

        # Store the loop counter/id in the loop variable
        if instr.loop_var:
            # The top of stack has the current iteration value
            if self.stack:
                self.put(instr.loop_var, self.peek())

        # Then fall through to condition check (like OP_WHILE)
        # The actual condition jump is handled by the next instruction

    @operator(Extended_Opcode.EOP_EXIT_ID)
    def exec_exit_id(self) -> None:
        """Exit from a named loop.

        Like EOP_EXIT but ignores the loop ID operand.
        """
        frame = self.current_frame
        # Find and exit the current loop
        jump_ip = self._find_loop_end_jump(frame)
        if jump_ip is not None:
            # Pop loop_stack for FOR loops
            if frame.loop_stack:
                frame.loop_stack.pop()
            # Set IP to the JUMP; step() will increment past it
            frame.ip = jump_ip

    @operator(Extended_Opcode.EOP_FOR_LIST_2)
    def exec_for_list_2(self) -> None:
        """For-list loop with index: for val, idx in (list|string|map)

        Like EOP_FOR_LIST_1 but also stores a second variable:
        - For lists/strings: (value, 1-based index)
        - For maps: (value, key)
        Loop state stored on frame.loop_stack as: ('list2', ip, collection, iter_state)
        """
        frame = self.current_frame
        instr = frame.current_instruction
        loop_var = instr.loop_var  # The value variable
        loop_idx_var = instr.loop_index  # The index/key variable
        if loop_var is None or loop_idx_var is None:
            raise VMError("FOR_LIST_2 requires both loop_var and loop_index")

        # Check if we have existing loop state for this IP
        loop_stack_index: int | None = None
        for i, entry in enumerate(frame.loop_stack):
            if len(entry) >= 2 and entry[0] == 'list2' and entry[1] == frame.ip:
                loop_stack_index = i
                break

        if loop_stack_index is None:
            # First entry into loop
            base_collection = self.pop()

            # Type check: must be string, list, or map
            if not isinstance(base_collection, (MOOString, str, MOOList, MOOMap)):
                raise MOOException(MOOError.E_TYPE)

            # Check for empty collection
            if len(base_collection) == 0:
                self._skip_to_end_of_for_loop(frame)
                return

            # Get first element and index/key based on type
            if isinstance(base_collection, (MOOString, str)):
                # For strings: (character, 1-based index)
                self.put(loop_var, MOOString(str(base_collection)[0]))
                self.put(loop_idx_var, 1)  # 1-based index
                frame.loop_stack.append(('list2', frame.ip, base_collection, 1))  # 0-based for next
            elif isinstance(base_collection, MOOList):
                # For lists: (element, 1-based index)
                self.put(loop_var, base_collection[1])
                self.put(loop_idx_var, 1)  # 1-based index
                frame.loop_stack.append(('list2', frame.ip, base_collection, 2))
            elif isinstance(base_collection, MOOMap):
                # For maps: (value, key) - note the order!
                keys_list = list(base_collection.keys())
                first_key = keys_list[0]
                first_value = base_collection[first_key]
                self.put(loop_var, first_value)  # Value first
                self.put(loop_idx_var, first_key)  # Key second
                frame.loop_stack.append(('list2', frame.ip, base_collection, 1))  # 0-based for next
        else:
            # Subsequent iteration
            _, _, base_collection, iter_state = frame.loop_stack[loop_stack_index]

            if isinstance(base_collection, (MOOString, str)):
                # String iteration: iter_state is 0-based index for next char
                if iter_state >= len(base_collection):
                    frame.loop_stack.pop(loop_stack_index)
                    self._skip_to_end_of_for_loop(frame)
                    return
                self.put(loop_var, MOOString(str(base_collection)[iter_state]))
                self.put(loop_idx_var, iter_state + 1)  # 1-based index
                frame.loop_stack[loop_stack_index] = ('list2', frame.ip, base_collection, iter_state + 1)
            elif isinstance(base_collection, MOOList):
                # List iteration: iter_state is 1-based index for next element
                if iter_state > len(base_collection):
                    frame.loop_stack.pop(loop_stack_index)
                    self._skip_to_end_of_for_loop(frame)
                    return
                self.put(loop_var, base_collection[iter_state])
                self.put(loop_idx_var, iter_state)  # 1-based index
                frame.loop_stack[loop_stack_index] = ('list2', frame.ip, base_collection, iter_state + 1)
            elif isinstance(base_collection, MOOMap):
                # Map iteration: iter_state is 0-based index into keys
                keys_list = list(base_collection.keys())
                if iter_state >= len(keys_list):
                    frame.loop_stack.pop(loop_stack_index)
                    self._skip_to_end_of_for_loop(frame)
                    return
                key = keys_list[iter_state]
                value = base_collection[key]
                self.put(loop_var, value)  # Value first
                self.put(loop_idx_var, key)  # Key second
                frame.loop_stack[loop_stack_index] = ('list2', frame.ip, base_collection, iter_state + 1)
